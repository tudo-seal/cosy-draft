{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CoSy","text":"Quick Start Get started with synthesis.  Predicates Concise Specification.  Advanced For Power-Users.  Examples Most telling examples.  Best Practice Guidelines for efficiency.  Troubleshoot Most common errors."},{"location":"#about","title":"About","text":"<p>This is just a suggestion text. </p> <p>CoSy is short for Combinatory Synthesizer.  It is an easy to use, comfortable, even cosy, framework that allows synthesizing target artifacts from modular compontents.  Due to the domain-agnostic nature of the framework (while implemented in python, arbitrary artifacts can be created),  it is by-and-large applicable to any use-case that benefits or inherently makes use of modularization. </p>"},{"location":"#papers","title":"Papers","text":"<p>There is a large body of work concerning combinatory logic synthesis, utilizing CoSy (formerly known as the CLS-framework).  It has been utilized for robotics, logistics, CAD assemblies, factory planning, and many more.  An overview over relevant literature, split into applications of CoSy and the theory behind it, is found in the following.</p>"},{"location":"#applications","title":"Applications","text":""},{"location":"#theory","title":"Theory","text":""},{"location":"quick-start/","title":"Quick Start","text":"<p>Provides a guide and a toy example of how to create a repository and generate some results. </p>"},{"location":"about/authors/","title":"Authors","text":""},{"location":"about/authors/#maintainers","title":"Maintainers","text":"<ul> <li>Constantin Chaumet (Structure) </li> <li>Andrej Dudenhefner (Features) </li> </ul>"},{"location":"about/authors/#contributors","title":"Contributors","text":"<ul> <li>Felix Laarmann </li> <li>Christoph Stahl </li> </ul>"},{"location":"examples/introduction/","title":"Introduction to the Examples","text":"<p>Briefly explain the different kinds of examples and what takeaways from them should be.  Takeaways should also be explained in each example in more detail. </p>"},{"location":"features/advanced/","title":"Advanced Usage","text":"<p>Documents how to access, use, and modify, the internal combinatory logic synthesizer of CoSy. </p>"},{"location":"features/predicates/","title":"Predicates","text":"<p>Documents what Predicates are, as well as when and how to use them. </p>"},{"location":"guidelines/best-practice/","title":"Best Practice","text":"<p>Documents best practice when modeling a use-case. </p>"},{"location":"guidelines/troubleshoot/","title":"Troubleshoot","text":"<p>An aggregation of information that can help debug and troubleshoot the synthesis. </p>"},{"location":"guidelines/troubleshoot/#common-errors","title":"Common Errors","text":"<p>Documents the types of errors that the CoSy developers and users have observed to occur often. </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cosy<ul> <li>_version</li> <li>combinatorics</li> <li>dsl</li> <li>inspector</li> <li>solution_space</li> <li>subtypes</li> <li>synthesizer</li> <li>tree</li> <li>types</li> </ul> </li> </ul>"},{"location":"reference/cosy/__init__/","title":"init","text":""},{"location":"reference/cosy/__init__/#cosy","title":"<code>cosy</code>","text":""},{"location":"reference/cosy/__init__/#cosy.T","title":"<code>T = TypeVar('T', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.__all__","title":"<code>__all__ = ['DSL', 'Literal', 'Var', 'Subtypes', 'Type', 'Omega', 'Constructor', 'Arrow', 'Intersection', 'Synthesizer', 'SolutionSpace']</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow","title":"<code>Arrow</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Arrow(Type):\n    source: Type = field(init=True)\n    target: Type = field(init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return self.target.is_omega\n\n    def _size(self) -&gt; int:\n        return 1 + self.source.size + self.target.size\n\n    def _organized(self) -&gt; set[Type]:\n        if len(self.target.organized) == 0:\n            return set()\n        if len(self.target.organized) == 1:\n            return {self}\n        return {Arrow(self.source, tp) for tp in self.target.organized}\n\n    def _free_vars(self) -&gt; set[str]:\n        return set.union(self.source.free_vars, self.target.free_vars)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.source} -&gt; {self.target}\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Arrow(\n            self.source.subst(groups, substitution),\n            self.target.subst(groups, substitution),\n        )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Arrow.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.source","title":"<code>source: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.target","title":"<code>target: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.__init__","title":"<code>__init__(source: Type, target: Type, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Arrow.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Arrow.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.source} -&gt; {self.target}\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Arrow.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Arrow(\n        self.source.subst(groups, substitution),\n        self.target.subst(groups, substitution),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.CoSy","title":"<code>CoSy</code>","text":"Source code in <code>src/cosy/__init__.py</code> <pre><code>class CoSy(Generic[T]):\n    component_specifications: Mapping[T, Specification]\n    parameter_space: ParameterSpace | None = None\n    taxonomy: Taxonomy | None = None\n    _synthesizer: Synthesizer\n\n    def __init__(\n        self,\n        component_specifications: Mapping[T, Specification],\n        parameter_space: ParameterSpace | None = None,\n        taxonomy: Taxonomy | None = None,\n    ) -&gt; None:\n        self.component_specifications = component_specifications\n        self.parameter_space = parameter_space\n        self.taxonomy = taxonomy if taxonomy is not None else {}\n        self._synthesizer = Synthesizer(component_specifications, parameter_space, self.taxonomy)\n\n    def solve(self, query: Type, max_count: int = 100) -&gt; Iterable[Any]:\n        \"\"\"\n        Solves the given query by constructing a solution space and enumerating and interpreting the resulting trees.\n\n        :param query: The query to solve.\n        :param max_count: The maximum number of trees to enumerate.\n        :return: An iterable of interpreted trees.\n        \"\"\"\n        if not isinstance(query, Type):\n            msg = \"Query must be of type Type\"\n            raise TypeError(msg)\n        solution_space = self._synthesizer.construct_solution_space(query).prune()\n\n        trees = solution_space.enumerate_trees(query, max_count=max_count)\n        for tree in trees:\n            yield tree.interpret()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.CoSy.component_specifications","title":"<code>component_specifications: Mapping[T, Specification] = component_specifications</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.CoSy.parameter_space","title":"<code>parameter_space: ParameterSpace | None = parameter_space</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.CoSy.taxonomy","title":"<code>taxonomy: Taxonomy | None = taxonomy if taxonomy is not None else {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.CoSy.__init__","title":"<code>__init__(component_specifications: Mapping[T, Specification], parameter_space: ParameterSpace | None = None, taxonomy: Taxonomy | None = None) -&gt; None</code>","text":"Source code in <code>src/cosy/__init__.py</code> <pre><code>def __init__(\n    self,\n    component_specifications: Mapping[T, Specification],\n    parameter_space: ParameterSpace | None = None,\n    taxonomy: Taxonomy | None = None,\n) -&gt; None:\n    self.component_specifications = component_specifications\n    self.parameter_space = parameter_space\n    self.taxonomy = taxonomy if taxonomy is not None else {}\n    self._synthesizer = Synthesizer(component_specifications, parameter_space, self.taxonomy)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.CoSy.solve","title":"<code>solve(query: Type, max_count: int = 100) -&gt; Iterable[Any]</code>","text":"<p>Solves the given query by constructing a solution space and enumerating and interpreting the resulting trees.</p> <p>:param query: The query to solve. :param max_count: The maximum number of trees to enumerate. :return: An iterable of interpreted trees.</p> Source code in <code>src/cosy/__init__.py</code> <pre><code>def solve(self, query: Type, max_count: int = 100) -&gt; Iterable[Any]:\n    \"\"\"\n    Solves the given query by constructing a solution space and enumerating and interpreting the resulting trees.\n\n    :param query: The query to solve.\n    :param max_count: The maximum number of trees to enumerate.\n    :return: An iterable of interpreted trees.\n    \"\"\"\n    if not isinstance(query, Type):\n        msg = \"Query must be of type Type\"\n        raise TypeError(msg)\n    solution_space = self._synthesizer.construct_solution_space(query).prune()\n\n    trees = solution_space.enumerate_trees(query, max_count=max_count)\n    for tree in trees:\n        yield tree.interpret()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Constructor","title":"<code>Constructor</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Constructor(Type):\n    name: str = field(init=True)\n    arg: Type = field(default=Omega(), init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1 + self.arg.size\n\n    def _organized(self) -&gt; set[Type]:\n        if len(self.arg.organized) &lt;= 1:\n            return {self}\n        return {Constructor(self.name, ap) for ap in self.arg.organized}\n\n    def _free_vars(self) -&gt; set[str]:\n        return self.arg.free_vars\n\n    def __str__(self) -&gt; str:\n        if self.arg == Omega():\n            return str(self.name)\n        return f\"{self.name!s}({self.arg!s})\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Constructor(self.name, self.arg.subst(groups, substitution))\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Constructor.arg","title":"<code>arg: Type = field(default=Omega(), init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.name","title":"<code>name: str = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.__init__","title":"<code>__init__(name: str, arg: Type = Omega(), *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Constructor.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Constructor.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.arg == Omega():\n        return str(self.name)\n    return f\"{self.name!s}({self.arg!s})\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Constructor.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Constructor(self.name, self.arg.subst(groups, substitution))\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL","title":"<code>DSL</code>","text":"<p>A domain-specific language (DSL) to define component specifications.</p> <p>This class provides a interface for defining specifications in a declarative manner. It allows users to specify the name and group of each parameter, as well as filter.</p> <p>Examples:</p> <p>DSL()     .Parameter(\"x\", int)     .Parameter(\"y\", int, lambda vars: vars[\"x\"] + 1)     .Parameter(\"z\", str)     .ParameterConstraint(lambda vars: len(vars[\"z\"]) == vars[\"x\"] + vars[\"y\"])     .Suffix() <p>constructs a specification for a function with three parameters: - <code>x</code>: an integer - <code>y</code>: an integer, the value of which is <code>x</code> + 1 - <code>z</code>: a string, whose length is equal to <code>x</code> + <code>y</code> The <code>Suffix</code> method specifies the function, which uses the variables <code>x</code>, <code>y</code>, and <code>z</code>.</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>class DSL:\n    \"\"\"\n    A domain-specific language (DSL) to define component specifications.\n\n    This class provides a interface for defining specifications in a declarative manner. It allows\n    users to specify the name and group of each parameter, as well as filter.\n\n    Examples:\n        DSL()\n            .Parameter(\"x\", int)\n            .Parameter(\"y\", int, lambda vars: vars[\"x\"] + 1)\n            .Parameter(\"z\", str)\n            .ParameterConstraint(lambda vars: len(vars[\"z\"]) == vars[\"x\"] + vars[\"y\"])\n            .Suffix(&lt;Type using Var(\"x\"), Var(\"y\") and Var(\"z\")&gt;)\n\n        constructs a specification for a function with three parameters:\n        - `x`: an integer\n        - `y`: an integer, the value of which is `x` + 1\n        - `z`: a string, whose length is equal to `x` + `y`\n        The `Suffix` method specifies the function, which uses the variables `x`, `y`, and `z`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the DSL object\n        \"\"\"\n\n        self._result: Callable[[Specification], Specification] = lambda suffix: suffix\n\n    def parameter(  #\n        self,\n        name: str,\n        group: str,\n        candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None,\n    ) -&gt; DSL:\n        \"\"\"\n        Introduce a new parameter variable.\n\n        `group` is a string, and an instance of this specification will be generated\n        for each valid literal in the corresponding literal group.\n        You can use this variable as Var(name) in all `Type`s, after the introduction\n        and in all predicates.\n        Optionally, you can specify a sequence of candidate values, that will be used to generate\n        the literals. This sequence is parameterized by the values of previously\n        defined literal variables. This is useful, if you want to restrict the values of a variable\n        to a subset of the values in the corresponding literal group.\n\n        :param name: The name of the new variable.\n        :type name: str\n        :param group: The group of the variable.\n        :type group: str\n        :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals.\n        :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Abstraction(LiteralParameter(name, group, candidates), suffix))\n\n        self._result = new_result\n        return self\n\n    def argument(self, name: str, specification: Type) -&gt; DSL:\n        \"\"\"\n        Introduce a new variable.\n\n        `group` is a `Type`, and an instance will be generated for each tree, satisfying\n        the specification given by the type. Since this can only be done in the enumeration step,\n        you can only use these variables in predicates, that themselves belong to variables whose `group` is a `Type`.\n\n        :param name: The name of the new variable.\n        :type name: str\n        :param specification: The type of the variable.\n        :type specification: Type\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Abstraction(TermParameter(name, specification), suffix))\n\n        self._result = new_result\n        return self\n\n    def parameter_constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n        \"\"\"\n        Constraint on the previously defined parameter variables.\n\n        :param constraint: A constraint deciding, if the currently chosen parameter values are valid.\n            The values of variables are passed by a dictionary, where the keys are the names of the\n            parameter variables and the values are the corresponding values.\n        :type constraint: Callable[[Mapping[str, Any]], bool]\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Implication(Predicate(constraint, True), suffix))\n\n        self._result = new_result\n        return self\n\n    def constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n        \"\"\"\n        Constraint on the previously defined parameter variables and argument variables.\n\n        :param constraint: A constraint deciding, if the currently chosen values are valid.\n            The values of variables are passed by a dictionary, where the keys are the names of the\n            variables and the values are the corresponding values.\n        :type constraint: Callable[[Mapping[str, Any]], bool]\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Implication(Predicate(constraint, False), suffix))\n\n        self._result = new_result\n        return self\n\n    def suffix(self, suffix: Type) -&gt; Specification:\n        \"\"\"\n        Constructs the final specification wrapping the given `Type` `suffix`.\n\n        :param suffix: The wrapped type.\n        :type suffix: Type\n        :return: The constructed specification.\n        :rtype: Abstraction | Type\n        \"\"\"\n        return self._result(suffix)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the DSL object</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the DSL object\n    \"\"\"\n\n    self._result: Callable[[Specification], Specification] = lambda suffix: suffix\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.argument","title":"<code>argument(name: str, specification: Type) -&gt; DSL</code>","text":"<p>Introduce a new variable.</p> <p><code>group</code> is a <code>Type</code>, and an instance will be generated for each tree, satisfying the specification given by the type. Since this can only be done in the enumeration step, you can only use these variables in predicates, that themselves belong to variables whose <code>group</code> is a <code>Type</code>.</p> <p>:param name: The name of the new variable. :type name: str :param specification: The type of the variable. :type specification: Type :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def argument(self, name: str, specification: Type) -&gt; DSL:\n    \"\"\"\n    Introduce a new variable.\n\n    `group` is a `Type`, and an instance will be generated for each tree, satisfying\n    the specification given by the type. Since this can only be done in the enumeration step,\n    you can only use these variables in predicates, that themselves belong to variables whose `group` is a `Type`.\n\n    :param name: The name of the new variable.\n    :type name: str\n    :param specification: The type of the variable.\n    :type specification: Type\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Abstraction(TermParameter(name, specification), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.constraint","title":"<code>constraint(constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL</code>","text":"<p>Constraint on the previously defined parameter variables and argument variables.</p> <p>:param constraint: A constraint deciding, if the currently chosen values are valid.     The values of variables are passed by a dictionary, where the keys are the names of the     variables and the values are the corresponding values. :type constraint: Callable[[Mapping[str, Any]], bool] :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n    \"\"\"\n    Constraint on the previously defined parameter variables and argument variables.\n\n    :param constraint: A constraint deciding, if the currently chosen values are valid.\n        The values of variables are passed by a dictionary, where the keys are the names of the\n        variables and the values are the corresponding values.\n    :type constraint: Callable[[Mapping[str, Any]], bool]\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Implication(Predicate(constraint, False), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.parameter","title":"<code>parameter(name: str, group: str, candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None) -&gt; DSL</code>","text":"<p>Introduce a new parameter variable.</p> <p><code>group</code> is a string, and an instance of this specification will be generated for each valid literal in the corresponding literal group. You can use this variable as Var(name) in all <code>Type</code>s, after the introduction and in all predicates. Optionally, you can specify a sequence of candidate values, that will be used to generate the literals. This sequence is parameterized by the values of previously defined literal variables. This is useful, if you want to restrict the values of a variable to a subset of the values in the corresponding literal group.</p> <p>:param name: The name of the new variable. :type name: str :param group: The group of the variable. :type group: str :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals. :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def parameter(  #\n    self,\n    name: str,\n    group: str,\n    candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None,\n) -&gt; DSL:\n    \"\"\"\n    Introduce a new parameter variable.\n\n    `group` is a string, and an instance of this specification will be generated\n    for each valid literal in the corresponding literal group.\n    You can use this variable as Var(name) in all `Type`s, after the introduction\n    and in all predicates.\n    Optionally, you can specify a sequence of candidate values, that will be used to generate\n    the literals. This sequence is parameterized by the values of previously\n    defined literal variables. This is useful, if you want to restrict the values of a variable\n    to a subset of the values in the corresponding literal group.\n\n    :param name: The name of the new variable.\n    :type name: str\n    :param group: The group of the variable.\n    :type group: str\n    :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals.\n    :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Abstraction(LiteralParameter(name, group, candidates), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.parameter_constraint","title":"<code>parameter_constraint(constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL</code>","text":"<p>Constraint on the previously defined parameter variables.</p> <p>:param constraint: A constraint deciding, if the currently chosen parameter values are valid.     The values of variables are passed by a dictionary, where the keys are the names of the     parameter variables and the values are the corresponding values. :type constraint: Callable[[Mapping[str, Any]], bool] :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def parameter_constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n    \"\"\"\n    Constraint on the previously defined parameter variables.\n\n    :param constraint: A constraint deciding, if the currently chosen parameter values are valid.\n        The values of variables are passed by a dictionary, where the keys are the names of the\n        parameter variables and the values are the corresponding values.\n    :type constraint: Callable[[Mapping[str, Any]], bool]\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Implication(Predicate(constraint, True), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.DSL.suffix","title":"<code>suffix(suffix: Type) -&gt; Specification</code>","text":"<p>Constructs the final specification wrapping the given <code>Type</code> <code>suffix</code>.</p> <p>:param suffix: The wrapped type. :type suffix: Type :return: The constructed specification. :rtype: Abstraction | Type</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def suffix(self, suffix: Type) -&gt; Specification:\n    \"\"\"\n    Constructs the final specification wrapping the given `Type` `suffix`.\n\n    :param suffix: The wrapped type.\n    :type suffix: Type\n    :return: The constructed specification.\n    :rtype: Abstraction | Type\n    \"\"\"\n    return self._result(suffix)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Intersection","title":"<code>Intersection</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Intersection(Type):\n    left: Type = field(init=True)\n    right: Type = field(init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return self.left.is_omega and self.right.is_omega\n\n    def _size(self) -&gt; int:\n        return 1 + self.left.size + self.right.size\n\n    def _organized(self) -&gt; set[Type]:\n        return set.union(self.left.organized, self.right.organized)\n\n    def _free_vars(self) -&gt; set[str]:\n        return set.union(self.left.free_vars, self.right.free_vars)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.left} &amp; {self.right}\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Intersection(\n            self.left.subst(groups, substitution),\n            self.right.subst(groups, substitution),\n        )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Intersection.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.left","title":"<code>left: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.right","title":"<code>right: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.__init__","title":"<code>__init__(left: Type, right: Type, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Intersection.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Intersection.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.left} &amp; {self.right}\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Intersection.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Intersection(\n        self.left.subst(groups, substitution),\n        self.right.subst(groups, substitution),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Literal","title":"<code>Literal</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Literal(Type):\n    value: Any  # has to be Hashable\n    group: str\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return {self}\n\n    def _free_vars(self) -&gt; set[str]:\n        return set()\n\n    def __str__(self) -&gt; str:\n        return f\"[{self.value!s}, {self.group}]\"\n\n    def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n        return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Literal.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.group","title":"<code>group: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.value","title":"<code>value: Any</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.__init__","title":"<code>__init__(value: Any, group: str, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Literal.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Literal.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"[{self.value!s}, {self.group}]\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Literal.subst","title":"<code>subst(_groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Omega","title":"<code>Omega</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Omega(Type):\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return True\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return set()\n\n    def __str__(self) -&gt; str:\n        return \"omega\"\n\n    def _free_vars(self) -&gt; set[str]:\n        return set()\n\n    def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n        return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Omega.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Omega.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Omega.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Omega.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Omega.__init__","title":"<code>__init__(*, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Omega.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Omega.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return \"omega\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Omega.subst","title":"<code>subst(_groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n    return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace","title":"<code>SolutionSpace</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>class SolutionSpace(Generic[NT, T, G]):\n    _rules: defaultdict[NT, deque[RHSRule[NT, T, G]]]\n\n    def __init__(self, rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None:\n        if rules is None:\n            rules = defaultdict(deque)\n        self._rules = defaultdict(deque, rules)\n\n    def get(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None:\n        return self._rules.get(nonterminal)\n\n    def __getitem__(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]:\n        return self._rules[nonterminal]\n\n    def nonterminals(self) -&gt; Iterable[NT]:\n        return self._rules.keys()\n\n    def as_tuples(self) -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]:\n        return self._rules.items()\n\n    def add_rule(\n        self,\n        nonterminal: NT,\n        terminal: T,\n        arguments: tuple[Argument, ...],\n        predicates: tuple[Callable[[dict[str, Any]], bool], ...],\n    ) -&gt; None:\n        self._rules[nonterminal].append(RHSRule(arguments, predicates, terminal))\n\n    def show(self) -&gt; str:\n        return \"\\n\".join(\n            f\"{nt!s} ~&gt; {' | '.join([str(subrule) for subrule in rule])}\" for nt, rule in self._rules.items()\n        )\n\n    def prune(self) -&gt; SolutionSpace[NT, T, G]:\n        \"\"\"Keep only productive rules.\"\"\"\n\n        ground_types: set[NT] = set()\n        queue: set[NT] = set()\n        inverse_grammar: dict[NT, set[tuple[NT, frozenset[NT]]]] = defaultdict(set)\n\n        for n, exprs in self._rules.items():\n            for expr in exprs:\n                non_terminals = expr.non_terminals\n                for m in non_terminals:\n                    inverse_grammar[m].add((n, non_terminals))\n                if not non_terminals:\n                    queue.add(n)\n\n        while queue:\n            n = queue.pop()\n            if n not in ground_types:\n                ground_types.add(n)\n                for m, non_terminals in inverse_grammar[n]:\n                    if m not in ground_types and all(t in ground_types for t in non_terminals):\n                        queue.add(m)\n\n        return SolutionSpace[NT, T, G](\n            defaultdict(\n                deque,\n                {\n                    target: deque(\n                        possibility\n                        for possibility in self._rules[target]\n                        if all(t in ground_types for t in possibility.non_terminals)\n                    )\n                    for target in ground_types\n                },\n            )\n        )\n\n    def _enumerate_tree_vectors(\n        self,\n        non_terminals: Sequence[NT | None],\n        existing_terms: Mapping[NT, set[Tree[T]]],\n        nt_term: tuple[NT, Tree[T]] | None = None,\n    ) -&gt; Iterable[tuple[Tree[T] | None, ...]]:\n        \"\"\"Enumerate possible term vectors for a given list of non-terminals and existing terms. Use nt_term at least once (if given).\"\"\"\n        if nt_term is None:\n            yield from product(*([n] if n is None else existing_terms[n] for n in non_terminals))\n        else:\n            nt, term = nt_term\n            for i, n in enumerate(non_terminals):\n                if n == nt:\n                    arg_lists: Iterable[Iterable[Tree[T] | None]] = (\n                        [None] if m is None else [term] if i == j else existing_terms[m]\n                        for j, m in enumerate(non_terminals)\n                    )\n                    yield from product(*arg_lists)\n\n    def _generate_new_trees(\n        self,\n        rule: RHSRule[NT, T, G],\n        existing_terms: Mapping[NT, set[Tree[T]]],\n        max_count: int | None = None,\n        nt_old_term: tuple[NT, Tree[T]] | None = None,\n    ) -&gt; set[Tree[T]]:\n        # Genererate new terms for rule `rule` from existing terms up to `max_count`\n        # the term `old_term` should be a subterm of all resulting terms, at a position, that corresponds to `nt`\n\n        output_set: set[Tree[T]] = set()\n        if max_count == 0:\n            return output_set\n\n        named_non_terminals = [\n            a.origin if isinstance(a, NonTerminalArgument) and a.name is not None else None for a in rule.arguments\n        ]\n        unnamed_non_terminals = [\n            a.origin if isinstance(a, NonTerminalArgument) and a.name is None else None for a in rule.arguments\n        ]\n        literal_arguments = [Tree(a.value, ()) if isinstance(a, ConstantArgument) else None for a in rule.arguments]\n\n        def interleave(\n            parameters: Sequence[Tree[T] | None],\n            literal_arguments: Sequence[Tree[T] | None],\n            arguments: Sequence[Tree[T] | None],\n        ) -&gt; Iterable[Tree[T]]:\n            \"\"\"Interleave parameters, literal arguments and arguments.\"\"\"\n            for parameter, literal_argument, argument in zip(parameters, literal_arguments, arguments, strict=True):\n                if parameter is not None:\n                    yield parameter\n                elif literal_argument is not None:\n                    yield literal_argument\n                elif argument is not None:\n                    yield argument\n                else:\n                    msg = \"All arguments of interleave are None\"\n                    raise ValueError(msg)\n\n        def construct_tree(\n            rule: RHSRule[NT, T, G],\n            parameters: Sequence[Tree[T] | None],\n            literal_arguments: Sequence[Tree[T] | None],\n            arguments: Sequence[Tree[T] | None],\n        ) -&gt; Tree[T]:\n            \"\"\"Construct a new tree from the rule and the given specific arguments.\"\"\"\n            return Tree(\n                rule.terminal,\n                tuple(interleave(parameters, literal_arguments, arguments)),\n            )\n\n        def specific_substitution(parameters):\n            return {\n                a.name: p\n                for p, a in zip(parameters, rule.arguments, strict=True)\n                if isinstance(a, NonTerminalArgument) and a.name is not None\n            } | rule.literal_substitution\n\n        def valid_parameters(\n            nt_term: tuple[NT, Tree[T]] | None,\n        ) -&gt; Iterable[tuple[Tree[T] | None, ...]]:\n            \"\"\"Enumerate all valid parameters for the rule.\"\"\"\n            for parameters in self._enumerate_tree_vectors(named_non_terminals, existing_terms, nt_term):\n                substitution = specific_substitution(parameters)\n                if all(predicate(substitution) for predicate in rule.predicates):\n                    yield parameters\n\n        for parameters in valid_parameters(nt_old_term):\n            for arguments in self._enumerate_tree_vectors(unnamed_non_terminals, existing_terms):\n                output_set.add(construct_tree(rule, parameters, literal_arguments, arguments))\n                if max_count is not None and len(output_set) &gt;= max_count:\n                    return output_set\n\n        if nt_old_term is not None:\n            all_parameters: deque[tuple[Tree[T] | None, ...]] | None = None\n            for arguments in self._enumerate_tree_vectors(unnamed_non_terminals, existing_terms):\n                all_parameters = all_parameters if all_parameters is not None else deque(valid_parameters(None))\n                for parameters in all_parameters:\n                    output_set.add(construct_tree(rule, parameters, literal_arguments, arguments))\n                    if max_count is not None and len(output_set) &gt;= max_count:\n                        return output_set\n        return output_set\n\n    def enumerate_trees(\n        self,\n        start: NT,\n        max_count: int | None = None,\n        max_bucket_size: int | None = None,\n    ) -&gt; Iterable[Tree[T]]:\n        \"\"\"\n        Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.\n        \"\"\"\n        if start not in self.nonterminals():\n            return\n\n        queues: dict[NT, PriorityQueue[Tree[T]]] = {n: PriorityQueue() for n in self.nonterminals()}\n        existing_terms: dict[NT, set[Tree[T]]] = {n: set() for n in self.nonterminals()}\n        inverse_grammar: dict[NT, deque[tuple[NT, RHSRule[NT, T, G]]]] = {n: deque() for n in self.nonterminals()}\n        all_results: set[Tree[T]] = set()\n\n        for n, exprs in self._rules.items():\n            for expr in exprs:\n                if expr.non_terminals.issubset(self.nonterminals()):\n                    for m in expr.non_terminals:\n                        if m in self.nonterminals():\n                            inverse_grammar[m].append((n, expr))\n                    for new_term in self._generate_new_trees(expr, existing_terms):\n                        queues[n].put(new_term)\n                        if n == start and new_term not in all_results:\n                            if max_count is not None and len(all_results) &gt;= max_count:\n                                return\n                            yield new_term\n                            all_results.add(new_term)\n\n        current_bucket_size = 1\n\n        while (max_bucket_size is None or current_bucket_size &lt;= max_bucket_size) and any(\n            not queue.empty() for queue in queues.values()\n        ):\n            non_terminals = {n for n in self.nonterminals() if not queues[n].empty()}\n\n            while non_terminals:\n                n = non_terminals.pop()\n                results = existing_terms[n]\n                while len(results) &lt; current_bucket_size and not queues[n].empty():\n                    term = queues[n].get()\n                    if term in results:\n                        continue\n                    results.add(term)\n                    for m, expr in inverse_grammar[n]:\n                        if len(existing_terms[m]) &lt; current_bucket_size:\n                            non_terminals.add(m)\n                        if m == start:\n                            for new_term in self._generate_new_trees(expr, existing_terms, max_count, (n, term)):\n                                if new_term not in all_results:\n                                    if max_count is not None and len(all_results) &gt;= max_count:\n                                        return\n                                    yield new_term\n                                    all_results.add(new_term)\n                                    queues[start].put(new_term)\n                        else:\n                            for new_term in self._generate_new_trees(expr, existing_terms, max_bucket_size, (n, term)):\n                                queues[m].put(new_term)\n            current_bucket_size += 1\n        return\n\n    def contains_tree(self, start: NT, tree: Tree[T]) -&gt; bool:\n        \"\"\"Check if the solution space contains a given `tree` derivable from `start`.\"\"\"\n        if start not in self.nonterminals():\n            return False\n\n        stack: deque[tuple | Callable] = deque([(start, tree)])\n        results: deque[bool] = deque()\n\n        def get_inputs(count: int) -&gt; Generator[bool]:\n            for _ in range(count):\n                yield results.pop()\n            return\n\n        while stack:\n            task = stack.pop()\n            if isinstance(task, tuple):\n                nt, tree = task\n                relevant_rhss = [\n                    rhs\n                    for rhs in self._rules[nt]\n                    if len(rhs.arguments) == len(tree.children)\n                    and rhs.terminal == tree.root\n                    and all(\n                        argument.value == child.root and len(child.children) == 0\n                        for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                        if isinstance(argument, ConstantArgument)\n                    )\n                ]\n\n                # if there is a relevant rule containing only TerminalArgument which are equal to the children of the tree\n                if any(\n                    all(isinstance(argument, ConstantArgument) for argument in rhs.arguments) for rhs in relevant_rhss\n                ):\n                    results.append(True)\n                    continue\n\n                # disjunction of the results for individual rules\n                def or_inputs(count: int = len(relevant_rhss)) -&gt; None:\n                    results.append(any(get_inputs(count)))\n\n                stack.append(or_inputs)\n\n                for rhs in relevant_rhss:\n                    substitution = {\n                        argument.name: child.root if isinstance(argument, ConstantArgument) else child\n                        for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                        if argument.name is not None\n                    }\n\n                    # conjunction of the results for individual arguments in the rule\n                    def and_inputs(\n                        count: int = sum(1 for argument in rhs.arguments if isinstance(argument, NonTerminalArgument)),\n                        substitution: dict[str, Any] = substitution,\n                        predicates=rhs.predicates,\n                    ) -&gt; None:\n                        results.append(\n                            all(get_inputs(count)) and all(predicate(substitution) for predicate in predicates)\n                        )\n\n                    stack.append(and_inputs)\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True):\n                        if isinstance(argument, NonTerminalArgument):\n                            stack.append((argument.origin, child))\n            elif isinstance(task, FunctionType):\n                # task is a function to execute\n                task()\n        return results.pop()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.__getitem__","title":"<code>__getitem__(nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def __getitem__(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]:\n    return self._rules[nonterminal]\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.__init__","title":"<code>__init__(rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def __init__(self, rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None:\n    if rules is None:\n        rules = defaultdict(deque)\n    self._rules = defaultdict(deque, rules)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.add_rule","title":"<code>add_rule(nonterminal: NT, terminal: T, arguments: tuple[Argument, ...], predicates: tuple[Callable[[dict[str, Any]], bool], ...]) -&gt; None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def add_rule(\n    self,\n    nonterminal: NT,\n    terminal: T,\n    arguments: tuple[Argument, ...],\n    predicates: tuple[Callable[[dict[str, Any]], bool], ...],\n) -&gt; None:\n    self._rules[nonterminal].append(RHSRule(arguments, predicates, terminal))\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.as_tuples","title":"<code>as_tuples() -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def as_tuples(self) -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]:\n    return self._rules.items()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.contains_tree","title":"<code>contains_tree(start: NT, tree: Tree[T]) -&gt; bool</code>","text":"<p>Check if the solution space contains a given <code>tree</code> derivable from <code>start</code>.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def contains_tree(self, start: NT, tree: Tree[T]) -&gt; bool:\n    \"\"\"Check if the solution space contains a given `tree` derivable from `start`.\"\"\"\n    if start not in self.nonterminals():\n        return False\n\n    stack: deque[tuple | Callable] = deque([(start, tree)])\n    results: deque[bool] = deque()\n\n    def get_inputs(count: int) -&gt; Generator[bool]:\n        for _ in range(count):\n            yield results.pop()\n        return\n\n    while stack:\n        task = stack.pop()\n        if isinstance(task, tuple):\n            nt, tree = task\n            relevant_rhss = [\n                rhs\n                for rhs in self._rules[nt]\n                if len(rhs.arguments) == len(tree.children)\n                and rhs.terminal == tree.root\n                and all(\n                    argument.value == child.root and len(child.children) == 0\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                    if isinstance(argument, ConstantArgument)\n                )\n            ]\n\n            # if there is a relevant rule containing only TerminalArgument which are equal to the children of the tree\n            if any(\n                all(isinstance(argument, ConstantArgument) for argument in rhs.arguments) for rhs in relevant_rhss\n            ):\n                results.append(True)\n                continue\n\n            # disjunction of the results for individual rules\n            def or_inputs(count: int = len(relevant_rhss)) -&gt; None:\n                results.append(any(get_inputs(count)))\n\n            stack.append(or_inputs)\n\n            for rhs in relevant_rhss:\n                substitution = {\n                    argument.name: child.root if isinstance(argument, ConstantArgument) else child\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                    if argument.name is not None\n                }\n\n                # conjunction of the results for individual arguments in the rule\n                def and_inputs(\n                    count: int = sum(1 for argument in rhs.arguments if isinstance(argument, NonTerminalArgument)),\n                    substitution: dict[str, Any] = substitution,\n                    predicates=rhs.predicates,\n                ) -&gt; None:\n                    results.append(\n                        all(get_inputs(count)) and all(predicate(substitution) for predicate in predicates)\n                    )\n\n                stack.append(and_inputs)\n                for argument, child in zip(rhs.arguments, tree.children, strict=True):\n                    if isinstance(argument, NonTerminalArgument):\n                        stack.append((argument.origin, child))\n        elif isinstance(task, FunctionType):\n            # task is a function to execute\n            task()\n    return results.pop()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.enumerate_trees","title":"<code>enumerate_trees(start: NT, max_count: int | None = None, max_bucket_size: int | None = None) -&gt; Iterable[Tree[T]]</code>","text":"<p>Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def enumerate_trees(\n    self,\n    start: NT,\n    max_count: int | None = None,\n    max_bucket_size: int | None = None,\n) -&gt; Iterable[Tree[T]]:\n    \"\"\"\n    Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.\n    \"\"\"\n    if start not in self.nonterminals():\n        return\n\n    queues: dict[NT, PriorityQueue[Tree[T]]] = {n: PriorityQueue() for n in self.nonterminals()}\n    existing_terms: dict[NT, set[Tree[T]]] = {n: set() for n in self.nonterminals()}\n    inverse_grammar: dict[NT, deque[tuple[NT, RHSRule[NT, T, G]]]] = {n: deque() for n in self.nonterminals()}\n    all_results: set[Tree[T]] = set()\n\n    for n, exprs in self._rules.items():\n        for expr in exprs:\n            if expr.non_terminals.issubset(self.nonterminals()):\n                for m in expr.non_terminals:\n                    if m in self.nonterminals():\n                        inverse_grammar[m].append((n, expr))\n                for new_term in self._generate_new_trees(expr, existing_terms):\n                    queues[n].put(new_term)\n                    if n == start and new_term not in all_results:\n                        if max_count is not None and len(all_results) &gt;= max_count:\n                            return\n                        yield new_term\n                        all_results.add(new_term)\n\n    current_bucket_size = 1\n\n    while (max_bucket_size is None or current_bucket_size &lt;= max_bucket_size) and any(\n        not queue.empty() for queue in queues.values()\n    ):\n        non_terminals = {n for n in self.nonterminals() if not queues[n].empty()}\n\n        while non_terminals:\n            n = non_terminals.pop()\n            results = existing_terms[n]\n            while len(results) &lt; current_bucket_size and not queues[n].empty():\n                term = queues[n].get()\n                if term in results:\n                    continue\n                results.add(term)\n                for m, expr in inverse_grammar[n]:\n                    if len(existing_terms[m]) &lt; current_bucket_size:\n                        non_terminals.add(m)\n                    if m == start:\n                        for new_term in self._generate_new_trees(expr, existing_terms, max_count, (n, term)):\n                            if new_term not in all_results:\n                                if max_count is not None and len(all_results) &gt;= max_count:\n                                    return\n                                yield new_term\n                                all_results.add(new_term)\n                                queues[start].put(new_term)\n                    else:\n                        for new_term in self._generate_new_trees(expr, existing_terms, max_bucket_size, (n, term)):\n                            queues[m].put(new_term)\n        current_bucket_size += 1\n    return\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.get","title":"<code>get(nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def get(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None:\n    return self._rules.get(nonterminal)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.nonterminals","title":"<code>nonterminals() -&gt; Iterable[NT]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def nonterminals(self) -&gt; Iterable[NT]:\n    return self._rules.keys()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.prune","title":"<code>prune() -&gt; SolutionSpace[NT, T, G]</code>","text":"<p>Keep only productive rules.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def prune(self) -&gt; SolutionSpace[NT, T, G]:\n    \"\"\"Keep only productive rules.\"\"\"\n\n    ground_types: set[NT] = set()\n    queue: set[NT] = set()\n    inverse_grammar: dict[NT, set[tuple[NT, frozenset[NT]]]] = defaultdict(set)\n\n    for n, exprs in self._rules.items():\n        for expr in exprs:\n            non_terminals = expr.non_terminals\n            for m in non_terminals:\n                inverse_grammar[m].add((n, non_terminals))\n            if not non_terminals:\n                queue.add(n)\n\n    while queue:\n        n = queue.pop()\n        if n not in ground_types:\n            ground_types.add(n)\n            for m, non_terminals in inverse_grammar[n]:\n                if m not in ground_types and all(t in ground_types for t in non_terminals):\n                    queue.add(m)\n\n    return SolutionSpace[NT, T, G](\n        defaultdict(\n            deque,\n            {\n                target: deque(\n                    possibility\n                    for possibility in self._rules[target]\n                    if all(t in ground_types for t in possibility.non_terminals)\n                )\n                for target in ground_types\n            },\n        )\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.SolutionSpace.show","title":"<code>show() -&gt; str</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def show(self) -&gt; str:\n    return \"\\n\".join(\n        f\"{nt!s} ~&gt; {' | '.join([str(subrule) for subrule in rule])}\" for nt, rule in self._rules.items()\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Subtypes","title":"<code>Subtypes</code>","text":"Source code in <code>src/cosy/subtypes.py</code> <pre><code>class Subtypes:\n    def __init__(self, taxonomy: Taxonomy):\n        self.taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))\n\n    def _check_subtype_rec(\n        self,\n        subtypes: deque[Type],\n        supertype: Type,\n        groups: Mapping[str, str],\n        substitutions: Mapping[str, Literal],\n    ) -&gt; bool:\n        if supertype.is_omega:\n            return True\n        match supertype:\n            case Literal(value2, group2):\n                while subtypes:\n                    match subtypes.pop():\n                        case Literal(value1, group1):\n                            if value2 == value1 and group1 == group2:\n                                return True\n                        case Var(name1):\n                            if groups[name1] == supertype.group and substitutions[name1] == supertype.value:\n                                return True\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return False\n            case Constructor(name2, arg2):\n                casted_constr: deque[Type] = deque()\n                while subtypes:\n                    match subtypes.pop():\n                        case Constructor(name1, arg1):\n                            if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                                casted_constr.append(arg1)\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return len(casted_constr) != 0 and self._check_subtype_rec(casted_constr, arg2, groups, substitutions)\n            case Arrow(src2, tgt2):\n                casted_arr: deque[Type] = deque()\n                while subtypes:\n                    match subtypes.pop():\n                        case Arrow(src1, tgt1):\n                            if self._check_subtype_rec(deque((src2,)), src1, groups, substitutions):\n                                casted_arr.append(tgt1)\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return len(casted_arr) != 0 and self._check_subtype_rec(casted_arr, tgt2, groups, substitutions)\n            case Intersection(l, r):\n                return self._check_subtype_rec(subtypes.copy(), l, groups, substitutions) and self._check_subtype_rec(\n                    subtypes, r, groups, substitutions\n                )\n            case Var(name):\n                while subtypes:\n                    match subtypes.pop():\n                        case Literal(value, group):\n                            if groups[name] == group and substitutions[name] == value:\n                                return True\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return False\n            case _:\n                msg = f\"Unsupported type in check_subtype: {supertype}\"\n                raise TypeError(msg)\n\n    def check_subtype(\n        self,\n        subtype: Type,\n        supertype: Type,\n        groups: Mapping[str, str],\n        substitutions: Mapping[str, Literal],\n    ) -&gt; bool:\n        \"\"\"Decides whether subtype &lt;= supertype with respect to intersection type subtyping.\"\"\"\n\n        return self._check_subtype_rec(deque((subtype,)), supertype, groups, substitutions)\n\n    def infer_substitution(self, subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None:\n        \"\"\"Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.\"\"\"\n\n        if subtype.is_omega:\n            return None\n\n        match subtype:\n            case Literal(value1, group1):\n                match path:\n                    case Literal(value2, group2):\n                        if value1 == value2 and group1 == group2:\n                            return {}\n            case Constructor(name1, arg1):\n                match path:\n                    case Constructor(name2, arg2):\n                        if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                            if arg2.is_omega:\n                                return {}\n                            return self.infer_substitution(arg1, arg2, groups)\n            case Arrow(src1, tgt1):\n                match path:\n                    case Arrow(src2, tgt2):\n                        substitution = self.infer_substitution(tgt1, tgt2, groups)\n                        if substitution is None:\n                            return None\n                        if all(name in substitution for name in src1.free_vars):\n                            if self.check_subtype(src2, src1, groups, substitution):\n                                return substitution\n                            return None\n                        return {}  # there are actual non-Ambiguous cases (relevant in practice?)\n            case Intersection(l, r):\n                substitution1 = self.infer_substitution(l, path, groups)\n                substitution2 = self.infer_substitution(r, path, groups)\n                if substitution1 is None:\n                    return substitution2\n                if substitution2 is None:\n                    return substitution1\n                if all(\n                    (name in substitution2 and substitution2[name] == value for name, value in substitution1.items())\n                ):\n                    return substitution1  # substitution1 included in substitution2\n                if all(\n                    (name in substitution1 and substitution1[name] == value for name, value in substitution2.items())\n                ):\n                    return substitution2  # substitution2 included in substitution1\n                return {}\n            case Var(name):\n                match path:\n                    case Literal(value2, group2):\n                        if groups[name] == group2:\n                            return {name: value2}\n            case _:\n                msg = f\"Unsupported type in infer_substitution: {subtype}\"\n                raise TypeError(msg)\n        return None\n\n    @staticmethod\n    def _reflexive_closure(env: Mapping[str, set[str]]) -&gt; dict[str, set[str]]:\n        all_types: set[str] = set(env.keys())\n        for v in env.values():\n            all_types.update(v)\n        result: dict[str, set[str]] = {subtype: {subtype}.union(env.get(subtype, set())) for subtype in all_types}\n        return result\n\n    @staticmethod\n    def _transitive_closure(env: Mapping[str, set[str]]) -&gt; dict[str, set[str]]:\n        result: dict[str, set[str]] = {subtype: supertypes.copy() for (subtype, supertypes) in env.items()}\n        has_changed = True\n\n        while has_changed:\n            has_changed = False\n            for known_supertypes in result.values():\n                for supertype in known_supertypes.copy():\n                    to_add: set[str] = {\n                        new_supertype for new_supertype in result[supertype] if new_supertype not in known_supertypes\n                    }\n                    if to_add:\n                        has_changed = True\n                    known_supertypes.update(to_add)\n\n        return result\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Subtypes.taxonomy","title":"<code>taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Subtypes.__init__","title":"<code>__init__(taxonomy: Taxonomy)</code>","text":"Source code in <code>src/cosy/subtypes.py</code> <pre><code>def __init__(self, taxonomy: Taxonomy):\n    self.taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Subtypes.check_subtype","title":"<code>check_subtype(subtype: Type, supertype: Type, groups: Mapping[str, str], substitutions: Mapping[str, Literal]) -&gt; bool</code>","text":"<p>Decides whether subtype &lt;= supertype with respect to intersection type subtyping.</p> Source code in <code>src/cosy/subtypes.py</code> <pre><code>def check_subtype(\n    self,\n    subtype: Type,\n    supertype: Type,\n    groups: Mapping[str, str],\n    substitutions: Mapping[str, Literal],\n) -&gt; bool:\n    \"\"\"Decides whether subtype &lt;= supertype with respect to intersection type subtyping.\"\"\"\n\n    return self._check_subtype_rec(deque((subtype,)), supertype, groups, substitutions)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Subtypes.infer_substitution","title":"<code>infer_substitution(subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None</code>","text":"<p>Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.</p> Source code in <code>src/cosy/subtypes.py</code> <pre><code>def infer_substitution(self, subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None:\n    \"\"\"Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.\"\"\"\n\n    if subtype.is_omega:\n        return None\n\n    match subtype:\n        case Literal(value1, group1):\n            match path:\n                case Literal(value2, group2):\n                    if value1 == value2 and group1 == group2:\n                        return {}\n        case Constructor(name1, arg1):\n            match path:\n                case Constructor(name2, arg2):\n                    if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                        if arg2.is_omega:\n                            return {}\n                        return self.infer_substitution(arg1, arg2, groups)\n        case Arrow(src1, tgt1):\n            match path:\n                case Arrow(src2, tgt2):\n                    substitution = self.infer_substitution(tgt1, tgt2, groups)\n                    if substitution is None:\n                        return None\n                    if all(name in substitution for name in src1.free_vars):\n                        if self.check_subtype(src2, src1, groups, substitution):\n                            return substitution\n                        return None\n                    return {}  # there are actual non-Ambiguous cases (relevant in practice?)\n        case Intersection(l, r):\n            substitution1 = self.infer_substitution(l, path, groups)\n            substitution2 = self.infer_substitution(r, path, groups)\n            if substitution1 is None:\n                return substitution2\n            if substitution2 is None:\n                return substitution1\n            if all(\n                (name in substitution2 and substitution2[name] == value for name, value in substitution1.items())\n            ):\n                return substitution1  # substitution1 included in substitution2\n            if all(\n                (name in substitution1 and substitution1[name] == value for name, value in substitution2.items())\n            ):\n                return substitution2  # substitution2 included in substitution1\n            return {}\n        case Var(name):\n            match path:\n                case Literal(value2, group2):\n                    if groups[name] == group2:\n                        return {name: value2}\n        case _:\n            msg = f\"Unsupported type in infer_substitution: {subtype}\"\n            raise TypeError(msg)\n    return None\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Synthesizer","title":"<code>Synthesizer</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>class Synthesizer(Generic[C]):\n    def __init__(\n        self,\n        component_specifications: Mapping[C, Specification],\n        parameter_space: ParameterSpace | None = None,\n        taxonomy: Taxonomy | None = None,\n    ):\n        self.literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())\n        self.repository: tuple[tuple[C, CombinatorInfo], ...] = tuple(\n            (c, Synthesizer._function_types(self.literals, ty)) for c, ty in component_specifications.items()\n        )\n        self.subtypes = Subtypes(taxonomy if taxonomy is not None else {})\n\n    @staticmethod\n    def _function_types(\n        literals: ParameterSpace,\n        parameterized_type: Specification,\n    ) -&gt; CombinatorInfo:\n        \"\"\"Presents a type as a list of 0-ary, 1-ary, ..., n-ary function types.\"\"\"\n\n        def unary_function_types(ty: Type) -&gt; Iterable[tuple[Type, Type]]:\n            tys: deque[Type] = deque((ty,))\n            while tys:\n                match tys.pop():\n                    case Arrow(src, tgt) if not tgt.is_omega:\n                        yield (src, tgt)\n                    case Intersection(sigma, tau):\n                        tys.extend((sigma, tau))\n\n        prefix: list[LiteralParameter | TermParameter | Predicate] = []\n        variables: set[str] = set()\n        groups: dict[str, str] = {}\n        while not isinstance(parameterized_type, Type):\n            if isinstance(parameterized_type, Abstraction):\n                param = parameterized_type.parameter\n                if param.name in variables:\n                    # check if parameter names are unique\n                    msg = f\"Duplicate name: {param.name}\"\n                    raise ValueError(msg)\n                variables.add(param.name)\n                if isinstance(param, LiteralParameter):\n                    prefix.append(param)\n                    groups[param.name] = param.group\n                    # check if group is defined in the parameter space\n                    if param.group not in literals:\n                        msg = f\"Group {param.group} is not defined in the parameter space.\"\n                        raise ValueError(msg)\n                elif isinstance(param, TermParameter):\n                    prefix.append(param)\n                    for free_var in param.group.free_vars:\n                        if free_var not in groups:\n                            # check if each parameter variable is abstracted\n                            msg = f\"Parameter {free_var} is not abstracted.\"\n                            raise ValueError(msg)\n                parameterized_type = parameterized_type.body\n            elif isinstance(parameterized_type, Implication):\n                prefix.append(parameterized_type.predicate)\n                parameterized_type = parameterized_type.body\n\n        for free_var in parameterized_type.free_vars:\n            if free_var not in groups:\n                # check if each parameter variable is abstracted\n                msg = f\"Parameter {free_var} is not abstracted.\"\n                raise ValueError(msg)\n\n        current: list[MultiArrow] = [MultiArrow((), parameterized_type)]\n\n        multiarrows = []\n        while len(current) != 0:\n            multiarrows.append(current)\n            current = [\n                MultiArrow((*c.args, new_arg), new_tgt)\n                for c in current\n                for (new_arg, new_tgt) in unary_function_types(c.target)\n            ]\n\n        term_predicates: tuple[Callable[[dict[str, Any]], bool], ...] = tuple(\n            p.constraint for p in prefix if isinstance(p, Predicate) and not p.only_literals\n        )\n        return CombinatorInfo(prefix, groups, term_predicates, None, multiarrows)\n\n    def _enumerate_substitutions(\n        self,\n        prefix: list[LiteralParameter | TermParameter | Predicate],\n        substitution: dict[str, Any],\n    ) -&gt; Iterable[dict[str, Any]]:\n        \"\"\"Enumerate all substitutions for the given parameters fairly.\n        Take initial_substitution with inferred literals into account.\"\"\"\n\n        stack: deque[tuple[dict[str, Any], int, Iterator[Any] | None]] = deque([(substitution, 0, None)])\n\n        while stack:\n            substitution, index, generator = stack.pop()\n            if index &gt;= len(prefix):\n                # no more parameters to process\n                yield substitution\n                continue\n            parameter = prefix[index]\n            if isinstance(parameter, LiteralParameter):\n                if generator is None:\n                    if parameter.name in substitution:\n                        value = substitution[parameter.name]\n                        if parameter.values is not None and value not in parameter.values(substitution):\n                            # the inferred value is not in the set of values\n                            continue\n                        if value not in self.literals[parameter.group]:\n                            # the inferred value is not in the group\n                            continue\n                        stack.appendleft((substitution, index + 1, None))\n                    elif parameter.values is not None:\n                        stack.appendleft((substitution, index, iter(parameter.values(substitution))))\n                    else:\n                        concrete_values = self.literals[parameter.group]\n                        if not isinstance(concrete_values, Iterable):\n                            msg = f\"The value of {parameter.name} could not be inferred.\"\n                            raise RuntimeError(msg)\n                        else:\n                            stack.appendleft((substitution, index, iter(concrete_values)))\n                else:\n                    try:\n                        value = next(generator)\n                    except StopIteration:\n                        continue\n                    if value in self.literals[parameter.group]:\n                        stack.appendleft(({**substitution, parameter.name: value}, index + 1, None))\n                    stack.appendleft((substitution, index, generator))\n\n            elif isinstance(parameter, Predicate) and parameter.only_literals:\n                if parameter.constraint(substitution):\n                    # the predicate is satisfied\n                    stack.appendleft((substitution, index + 1, None))\n            else:\n                stack.appendleft((substitution, index + 1, None))\n\n    def _subqueries(\n        self,\n        nary_types: list[MultiArrow],\n        paths: Iterable[Type],\n        groups: dict[str, str],\n        substitution: dict[str, Any],\n    ) -&gt; Sequence[list[Type]]:\n        # does the target of a multi-arrow contain a given type?\n        def target_contains(m: MultiArrow, t: Type) -&gt; bool:\n            return self.subtypes.check_subtype(m.target, t, groups, substitution)\n\n        # cover target using targets of multi-arrows in nary_types\n        covers = minimal_covers(nary_types, paths, target_contains)\n        if len(covers) == 0:\n            return []\n\n        # intersect corresponding arguments of multi-arrows in each cover\n        def intersect_args(args1: Iterable[Type], args2: Iterable[Type]) -&gt; tuple[Type, ...]:\n            return tuple(Intersection(a, b) for a, b in zip(args1, args2, strict=False))\n\n        intersected_args: Generator[list[Type]] = (list(reduce(intersect_args, (m.args for m in ms))) for ms in covers)\n\n        # consider only maximal argument vectors\n        def compare_args(args1, args2) -&gt; bool:\n            return all(\n                map(\n                    lambda a, b: self.subtypes.check_subtype(a, b, groups, substitution),\n                    args1,\n                    args2,\n                )\n            )\n\n        return maximal_elements(intersected_args, compare_args)\n\n    def _necessary_substitution(\n        self,\n        paths: Iterable[Type],\n        combinator_type: list[list[MultiArrow]],\n        groups: dict[str, str],\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Computes a substitution that needs to be part of every substitution S such that\n        S(combinator_type) &lt;= paths.\n\n        If no substitution can make this valid, None is returned.\n        \"\"\"\n\n        result: dict[str, Any] = {}\n\n        for path in paths:\n            unique_substitution: dict[str, Any] | None = None\n            is_unique = True\n\n            for nary_types in combinator_type:\n                for ty in nary_types:\n                    substitution = self.subtypes.infer_substitution(ty.target, path, groups)\n                    if substitution is None:\n                        continue\n                    if unique_substitution is None:\n                        unique_substitution = substitution\n                    else:\n                        is_unique = False\n                        break\n                if not is_unique:\n                    break\n\n            if unique_substitution is None:\n                return None  # no substitution for this path\n            if not is_unique:\n                continue  # substitution not unique substitution \u2014 skip\n\n            # merge consistent substitution\n            for k, v in unique_substitution.items():\n                if k in result:\n                    if result[k] != v:\n                        return None  # conflict in necessary substitution\n                else:\n                    result[k] = v\n\n        return result\n\n    def construct_solution_space_rules(self, *targets: Type) -&gt; Generator[tuple[Type, RHSRule]]:\n        \"\"\"Generate logic program rules for the given target types.\"\"\"\n\n        # current target types\n        stack: deque[tuple[Type, tuple[C, CombinatorInfo, Iterator] | None]] = deque(\n            (target, None) for target in targets\n        )\n        seen: set[Type] = set()\n\n        while stack:\n            current_target, current_target_info = stack.pop()\n            # if the target is omega, then the result is junk\n            if current_target.is_omega:\n                msg = f\"Target type {current_target} is omega.\"\n                raise ValueError(msg)\n\n            # target type was not initialized before\n            if current_target not in seen or current_target_info is not None:\n                if current_target_info is None:\n                    seen.add(current_target)\n                    # try each combinator\n                    for combinator, combinator_info in self.repository:\n                        # Compute necessary substitutions\n                        substitution = self._necessary_substitution(\n                            current_target.organized,\n                            combinator_info.type,\n                            combinator_info.groups,\n                        )\n\n                        # If there cannot be a suitable substitution, ignore this combinator\n                        if substitution is None:\n                            continue\n\n                        # Keep necessary substitutions and enumerate the rest\n                        selected_instantiations = self._enumerate_substitutions(combinator_info.prefix, substitution)\n                        stack.appendleft(\n                            (\n                                current_target,\n                                (\n                                    combinator,\n                                    combinator_info,\n                                    iter(selected_instantiations),\n                                ),\n                            )\n                        )\n                else:\n                    combinator, combinator_info, selected_instantiations = current_target_info\n                    instantiation = next(selected_instantiations, None)\n                    if instantiation is not None:\n                        stack.appendleft((current_target, current_target_info))\n                        named_arguments: tuple[Argument, ...] | None = None\n\n                        # and every arity of the combinator type\n                        for nary_types in combinator_info.type:\n                            for subquery in self._subqueries(\n                                nary_types,\n                                current_target.organized,\n                                combinator_info.groups,\n                                instantiation,\n                            ):\n                                if named_arguments is None:  # do this only once for each instantiation\n                                    named_arguments = tuple(\n                                        ConstantArgument(\n                                            param.name,\n                                            instantiation[param.name],\n                                            combinator_info.groups[param.name],\n                                        )\n                                        if isinstance(param, LiteralParameter)\n                                        else NonTerminalArgument(\n                                            param.name,\n                                            param.group.subst(\n                                                combinator_info.groups,\n                                                instantiation,\n                                            ),\n                                        )\n                                        for param in combinator_info.prefix\n                                        if isinstance(param, Parameter)\n                                    )\n                                    stack.extendleft(\n                                        (argument.origin, None)\n                                        for argument in named_arguments\n                                        if isinstance(argument, NonTerminalArgument)\n                                    )\n\n                                anonymous_arguments: tuple[Argument, ...] = tuple(\n                                    NonTerminalArgument(\n                                        None,\n                                        ty.subst(combinator_info.groups, instantiation),\n                                    )\n                                    for ty in subquery\n                                )\n                                yield (\n                                    current_target,\n                                    RHSRule[Type, Any, str](\n                                        (*named_arguments, *anonymous_arguments),\n                                        combinator_info.term_predicates,\n                                        combinator,\n                                    ),\n                                )\n                                stack.extendleft((q.origin, None) for q in anonymous_arguments)\n\n    def construct_solution_space(self, *targets: Type) -&gt; SolutionSpace[Type, C, str]:\n        \"\"\"Constructs a logic program in the current environment for the given target types.\"\"\"\n\n        solution_space: SolutionSpace[Type, C, str] = SolutionSpace()\n        for nt, rule in self.construct_solution_space_rules(*targets):\n            solution_space.add_rule(nt, rule.terminal, rule.arguments, rule.predicates)\n\n        return solution_space\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Synthesizer.literals","title":"<code>literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Synthesizer.repository","title":"<code>repository: tuple[tuple[C, CombinatorInfo], ...] = tuple((c, Synthesizer._function_types(self.literals, ty)) for (c, ty) in component_specifications.items())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Synthesizer.subtypes","title":"<code>subtypes = Subtypes(taxonomy if taxonomy is not None else {})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Synthesizer.__init__","title":"<code>__init__(component_specifications: Mapping[C, Specification], parameter_space: ParameterSpace | None = None, taxonomy: Taxonomy | None = None)</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def __init__(\n    self,\n    component_specifications: Mapping[C, Specification],\n    parameter_space: ParameterSpace | None = None,\n    taxonomy: Taxonomy | None = None,\n):\n    self.literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())\n    self.repository: tuple[tuple[C, CombinatorInfo], ...] = tuple(\n        (c, Synthesizer._function_types(self.literals, ty)) for c, ty in component_specifications.items()\n    )\n    self.subtypes = Subtypes(taxonomy if taxonomy is not None else {})\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Synthesizer.construct_solution_space","title":"<code>construct_solution_space(*targets: Type) -&gt; SolutionSpace[Type, C, str]</code>","text":"<p>Constructs a logic program in the current environment for the given target types.</p> Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def construct_solution_space(self, *targets: Type) -&gt; SolutionSpace[Type, C, str]:\n    \"\"\"Constructs a logic program in the current environment for the given target types.\"\"\"\n\n    solution_space: SolutionSpace[Type, C, str] = SolutionSpace()\n    for nt, rule in self.construct_solution_space_rules(*targets):\n        solution_space.add_rule(nt, rule.terminal, rule.arguments, rule.predicates)\n\n    return solution_space\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Synthesizer.construct_solution_space_rules","title":"<code>construct_solution_space_rules(*targets: Type) -&gt; Generator[tuple[Type, RHSRule]]</code>","text":"<p>Generate logic program rules for the given target types.</p> Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def construct_solution_space_rules(self, *targets: Type) -&gt; Generator[tuple[Type, RHSRule]]:\n    \"\"\"Generate logic program rules for the given target types.\"\"\"\n\n    # current target types\n    stack: deque[tuple[Type, tuple[C, CombinatorInfo, Iterator] | None]] = deque(\n        (target, None) for target in targets\n    )\n    seen: set[Type] = set()\n\n    while stack:\n        current_target, current_target_info = stack.pop()\n        # if the target is omega, then the result is junk\n        if current_target.is_omega:\n            msg = f\"Target type {current_target} is omega.\"\n            raise ValueError(msg)\n\n        # target type was not initialized before\n        if current_target not in seen or current_target_info is not None:\n            if current_target_info is None:\n                seen.add(current_target)\n                # try each combinator\n                for combinator, combinator_info in self.repository:\n                    # Compute necessary substitutions\n                    substitution = self._necessary_substitution(\n                        current_target.organized,\n                        combinator_info.type,\n                        combinator_info.groups,\n                    )\n\n                    # If there cannot be a suitable substitution, ignore this combinator\n                    if substitution is None:\n                        continue\n\n                    # Keep necessary substitutions and enumerate the rest\n                    selected_instantiations = self._enumerate_substitutions(combinator_info.prefix, substitution)\n                    stack.appendleft(\n                        (\n                            current_target,\n                            (\n                                combinator,\n                                combinator_info,\n                                iter(selected_instantiations),\n                            ),\n                        )\n                    )\n            else:\n                combinator, combinator_info, selected_instantiations = current_target_info\n                instantiation = next(selected_instantiations, None)\n                if instantiation is not None:\n                    stack.appendleft((current_target, current_target_info))\n                    named_arguments: tuple[Argument, ...] | None = None\n\n                    # and every arity of the combinator type\n                    for nary_types in combinator_info.type:\n                        for subquery in self._subqueries(\n                            nary_types,\n                            current_target.organized,\n                            combinator_info.groups,\n                            instantiation,\n                        ):\n                            if named_arguments is None:  # do this only once for each instantiation\n                                named_arguments = tuple(\n                                    ConstantArgument(\n                                        param.name,\n                                        instantiation[param.name],\n                                        combinator_info.groups[param.name],\n                                    )\n                                    if isinstance(param, LiteralParameter)\n                                    else NonTerminalArgument(\n                                        param.name,\n                                        param.group.subst(\n                                            combinator_info.groups,\n                                            instantiation,\n                                        ),\n                                    )\n                                    for param in combinator_info.prefix\n                                    if isinstance(param, Parameter)\n                                )\n                                stack.extendleft(\n                                    (argument.origin, None)\n                                    for argument in named_arguments\n                                    if isinstance(argument, NonTerminalArgument)\n                                )\n\n                            anonymous_arguments: tuple[Argument, ...] = tuple(\n                                NonTerminalArgument(\n                                    None,\n                                    ty.subst(combinator_info.groups, instantiation),\n                                )\n                                for ty in subquery\n                            )\n                            yield (\n                                current_target,\n                                RHSRule[Type, Any, str](\n                                    (*named_arguments, *anonymous_arguments),\n                                    combinator_info.term_predicates,\n                                    combinator,\n                                ),\n                            )\n                            stack.extendleft((q.origin, None) for q in anonymous_arguments)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type","title":"<code>Type</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Type(ABC):\n    is_omega: bool = field(init=True, kw_only=True, compare=False)\n    size: int = field(init=True, kw_only=True, compare=False)\n    organized: set[Type] = field(init=True, kw_only=True, compare=False)\n    free_vars: set[str] = field(init=True, kw_only=True, compare=False)\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def _organized(self) -&gt; set[Type]:\n        pass\n\n    @abstractmethod\n    def _size(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def _is_omega(self) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def _free_vars(self) -&gt; set[str]:\n        pass\n\n    @abstractmethod\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        pass\n\n    @staticmethod\n    def intersect(types: Sequence[Type]) -&gt; Type:\n        if len(types) &gt; 0:\n            rtypes = reversed(types)\n            result: Type = next(rtypes)\n            for ty in rtypes:\n                result = Intersection(ty, result)\n            return result\n        return Omega()\n\n    def __getstate__(self) -&gt; dict[str, Any]:\n        state = self.__dict__.copy()\n        del state[\"is_omega\"]\n        del state[\"size\"]\n        del state[\"organized\"]\n        return state\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        self.__dict__.update(state)\n        self.__dict__[\"is_omega\"] = self._is_omega()\n        self.__dict__[\"size\"] = self._size()\n        self.__dict__[\"organized\"] = self._organized()\n\n    def __pow__(self, other: Type) -&gt; Type:\n        return Arrow(self, other)\n\n    def __and__(self, other: Type) -&gt; Type:\n        return Intersection(self, other)\n\n    def __rmatmul__(self, name: str) -&gt; Type:\n        return Constructor(name, self)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.free_vars","title":"<code>free_vars: set[str] = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Type.is_omega","title":"<code>is_omega: bool = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Type.organized","title":"<code>organized: set[Type] = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Type.size","title":"<code>size: int = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Type.__and__","title":"<code>__and__(other: Type) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __and__(self, other: Type) -&gt; Type:\n    return Intersection(self, other)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.__getstate__","title":"<code>__getstate__() -&gt; dict[str, Any]</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __getstate__(self) -&gt; dict[str, Any]:\n    state = self.__dict__.copy()\n    del state[\"is_omega\"]\n    del state[\"size\"]\n    del state[\"organized\"]\n    return state\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.__init__","title":"<code>__init__(*, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Type.__pow__","title":"<code>__pow__(other: Type) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __pow__(self, other: Type) -&gt; Type:\n    return Arrow(self, other)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.__rmatmul__","title":"<code>__rmatmul__(name: str) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __rmatmul__(self, name: str) -&gt; Type:\n    return Constructor(name, self)\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.__setstate__","title":"<code>__setstate__(state: dict[str, Any]) -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __setstate__(self, state: dict[str, Any]) -&gt; None:\n    self.__dict__.update(state)\n    self.__dict__[\"is_omega\"] = self._is_omega()\n    self.__dict__[\"size\"] = self._size()\n    self.__dict__[\"organized\"] = self._organized()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.__str__","title":"<code>__str__() -&gt; str</code>  <code>abstractmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@abstractmethod\ndef __str__(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.intersect","title":"<code>intersect(types: Sequence[Type]) -&gt; Type</code>  <code>staticmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@staticmethod\ndef intersect(types: Sequence[Type]) -&gt; Type:\n    if len(types) &gt; 0:\n        rtypes = reversed(types)\n        result: Type = next(rtypes)\n        for ty in rtypes:\n            result = Intersection(ty, result)\n        return result\n    return Omega()\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Type.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>  <code>abstractmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@abstractmethod\ndef subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    pass\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Var","title":"<code>Var</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Var(Type):\n    name: str\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return {self}\n\n    def _free_vars(self) -&gt; set[str]:\n        return {self.name}\n\n    def __str__(self) -&gt; str:\n        return f\"&lt;{self.name!s}&gt;\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if self.name in substitution:\n            return Literal(substitution[self.name], groups[self.name])\n        return self\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Var.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.__init__","title":"<code>__init__(name: str, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/__init__/#cosy.Var.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Var.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"&lt;{self.name!s}&gt;\"\n</code></pre>"},{"location":"reference/cosy/__init__/#cosy.Var.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if self.name in substitution:\n        return Literal(substitution[self.name], groups[self.name])\n    return self\n</code></pre>"},{"location":"reference/cosy/_version/","title":"_version","text":""},{"location":"reference/cosy/_version/#cosy._version","title":"<code>_version</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.TYPE_CHECKING","title":"<code>TYPE_CHECKING = False</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.VERSION_TUPLE","title":"<code>VERSION_TUPLE = Tuple[Union[int, str], ...]</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.__all__","title":"<code>__all__ = ['__version__', '__version_tuple__', 'version', 'version_tuple']</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.__version__","title":"<code>__version__: str = '0.0.5.dev5+g5158d91'</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.__version_tuple__","title":"<code>__version_tuple__: VERSION_TUPLE = (0, 0, 5, 'dev5', 'g5158d91')</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.version","title":"<code>version: str = '0.0.5.dev5+g5158d91'</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/_version/#cosy._version.version_tuple","title":"<code>version_tuple: VERSION_TUPLE = (0, 0, 5, 'dev5', 'g5158d91')</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/combinatorics/","title":"combinatorics","text":""},{"location":"reference/cosy/combinatorics/#cosy.combinatorics","title":"<code>combinatorics</code>","text":""},{"location":"reference/cosy/combinatorics/#cosy.combinatorics.E","title":"<code>E = TypeVar('E')</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/combinatorics/#cosy.combinatorics.S","title":"<code>S = TypeVar('S')</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/combinatorics/#cosy.combinatorics.maximal_elements","title":"<code>maximal_elements(elements: Iterable[E], compare: Callable[[E, E], bool]) -&gt; Sequence[E]</code>","text":"<p>Enumerate maximal elements with respect to compare.</p> <p><code>compare(e1, e2) == True</code> iff <code>e1</code> smaller or equal to <code>e2</code>.</p> Source code in <code>src/cosy/combinatorics.py</code> <pre><code>def maximal_elements(elements: Iterable[E], compare: Callable[[E, E], bool]) -&gt; Sequence[E]:\n    \"\"\"Enumerate maximal elements with respect to compare.\n\n    `compare(e1, e2) == True` iff `e1` smaller or equal to `e2`.\n    \"\"\"\n    candidates: deque[E] = deque(elements)\n    if len(candidates) &lt;= 1:\n        return candidates\n    new_candidates: deque[E] = deque()\n    result: deque[E] = deque()\n    while candidates:\n        e1 = candidates.pop()\n        while candidates:\n            e2 = candidates.pop()\n            if compare(e2, e1):\n                continue  # e2 is redundant\n            if compare(e1, e2):\n                e1 = e2  # e1 is redundant\n                candidates.extendleft(new_candidates)\n                new_candidates.clear()\n            else:\n                new_candidates.appendleft(e2)\n        candidates, new_candidates = new_candidates, candidates\n        result.appendleft(e1)\n    return result\n</code></pre>"},{"location":"reference/cosy/combinatorics/#cosy.combinatorics.minimal_covers","title":"<code>minimal_covers(sets: Sequence[S], to_cover: Iterable[E], contains: Callable[[S, E], bool]) -&gt; list[list[S]]</code>","text":"<p>List minimal covers of elements in to_cover using given sets.</p> <p>Properties of each <code>cover: list[S]</code> - for every <code>e: E</code> in <code>to_cover</code> there is at least one <code>s: S</code> in <code>cover</code> such that   <code>contains(s, e) == True</code> - no <code>s: S</code> can be removed from <code>cover</code></p> Source code in <code>src/cosy/combinatorics.py</code> <pre><code>def minimal_covers(sets: Sequence[S], to_cover: Iterable[E], contains: Callable[[S, E], bool]) -&gt; list[list[S]]:\n    \"\"\"List minimal covers of elements in to_cover using given sets.\n\n    Properties of each `cover: list[S]`\n    - for every `e: E` in `to_cover` there is at least one `s: S` in `cover` such that\n      `contains(s, e) == True`\n    - no `s: S` can be removed from `cover`\n    \"\"\"\n    # sets necessarily included in any cover\n    necessary_sets: set[int] = set()\n    # for each element e: sets containing e\n    relevant_sets: deque[set[int]] = deque()\n\n    for e in to_cover:\n        covering_sets = {j for j in range(len(sets)) if contains(sets[j], e)}\n        if len(covering_sets) == 0:  # at least one element cannot be covered\n            return []\n        if len(covering_sets) == 1:  # exactly one set is relevant\n            necessary_sets.add(covering_sets.pop())\n        else:  # more than one set is relevant\n            relevant_sets.append(covering_sets)\n\n    # collect minimal covers (there is no smaller or equivalent cover)\n    covers: deque[set[int]] = deque()\n    covers.appendleft(necessary_sets)\n    for r in relevant_sets:\n        partitioning = partition(r.isdisjoint, covers)\n        covers = partitioning[0].copy()\n        for c1 in partitioning[1]:\n            js: set[int] = r.copy()\n            for c2 in partitioning[0]:\n                missing = c2.difference(c1)\n                if len(missing) == 1:\n                    # c2 is a subset of c1 + {one missing element}\n                    js.discard(missing.pop())\n            for j in js:\n                new_c = c1.copy()\n                new_c.add(j)\n                covers.append(new_c)\n    return [[sets[j] for j in c] for c in covers]\n</code></pre>"},{"location":"reference/cosy/combinatorics/#cosy.combinatorics.partition","title":"<code>partition(predicate: Callable[[E], bool], elements: Iterable[E]) -&gt; tuple[deque[E], deque[E]]</code>","text":"<p>Partition elements of an Iterable according to a predicate. Narrowing types.</p> <p>Returns: (elements not satisfying predicate, elements satisfying predicate).</p> Source code in <code>src/cosy/combinatorics.py</code> <pre><code>def partition(predicate: Callable[[E], bool], elements: Iterable[E]) -&gt; tuple[deque[E], deque[E]]:\n    \"\"\"Partition elements of an Iterable according to a predicate. Narrowing types.\n\n    Returns: (elements not satisfying predicate, elements satisfying predicate).\"\"\"\n\n    partitioning: tuple[deque[E], deque[E]] = (deque[E](), deque[E]())\n    for element in elements:\n        if predicate(element):\n            partitioning[1].append(element)\n        else:\n            partitioning[0].append(element)\n    return partitioning\n</code></pre>"},{"location":"reference/cosy/dsl/","title":"dsl","text":""},{"location":"reference/cosy/dsl/#cosy.dsl","title":"<code>dsl</code>","text":"<p>This module provides a <code>DSL</code> class, which allows users to define specifications in a declarative manner using a fluent interface.</p>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL","title":"<code>DSL</code>","text":"<p>A domain-specific language (DSL) to define component specifications.</p> <p>This class provides a interface for defining specifications in a declarative manner. It allows users to specify the name and group of each parameter, as well as filter.</p> <p>Examples:</p> <p>DSL()     .Parameter(\"x\", int)     .Parameter(\"y\", int, lambda vars: vars[\"x\"] + 1)     .Parameter(\"z\", str)     .ParameterConstraint(lambda vars: len(vars[\"z\"]) == vars[\"x\"] + vars[\"y\"])     .Suffix() <p>constructs a specification for a function with three parameters: - <code>x</code>: an integer - <code>y</code>: an integer, the value of which is <code>x</code> + 1 - <code>z</code>: a string, whose length is equal to <code>x</code> + <code>y</code> The <code>Suffix</code> method specifies the function, which uses the variables <code>x</code>, <code>y</code>, and <code>z</code>.</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>class DSL:\n    \"\"\"\n    A domain-specific language (DSL) to define component specifications.\n\n    This class provides a interface for defining specifications in a declarative manner. It allows\n    users to specify the name and group of each parameter, as well as filter.\n\n    Examples:\n        DSL()\n            .Parameter(\"x\", int)\n            .Parameter(\"y\", int, lambda vars: vars[\"x\"] + 1)\n            .Parameter(\"z\", str)\n            .ParameterConstraint(lambda vars: len(vars[\"z\"]) == vars[\"x\"] + vars[\"y\"])\n            .Suffix(&lt;Type using Var(\"x\"), Var(\"y\") and Var(\"z\")&gt;)\n\n        constructs a specification for a function with three parameters:\n        - `x`: an integer\n        - `y`: an integer, the value of which is `x` + 1\n        - `z`: a string, whose length is equal to `x` + `y`\n        The `Suffix` method specifies the function, which uses the variables `x`, `y`, and `z`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the DSL object\n        \"\"\"\n\n        self._result: Callable[[Specification], Specification] = lambda suffix: suffix\n\n    def parameter(  #\n        self,\n        name: str,\n        group: str,\n        candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None,\n    ) -&gt; DSL:\n        \"\"\"\n        Introduce a new parameter variable.\n\n        `group` is a string, and an instance of this specification will be generated\n        for each valid literal in the corresponding literal group.\n        You can use this variable as Var(name) in all `Type`s, after the introduction\n        and in all predicates.\n        Optionally, you can specify a sequence of candidate values, that will be used to generate\n        the literals. This sequence is parameterized by the values of previously\n        defined literal variables. This is useful, if you want to restrict the values of a variable\n        to a subset of the values in the corresponding literal group.\n\n        :param name: The name of the new variable.\n        :type name: str\n        :param group: The group of the variable.\n        :type group: str\n        :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals.\n        :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Abstraction(LiteralParameter(name, group, candidates), suffix))\n\n        self._result = new_result\n        return self\n\n    def argument(self, name: str, specification: Type) -&gt; DSL:\n        \"\"\"\n        Introduce a new variable.\n\n        `group` is a `Type`, and an instance will be generated for each tree, satisfying\n        the specification given by the type. Since this can only be done in the enumeration step,\n        you can only use these variables in predicates, that themselves belong to variables whose `group` is a `Type`.\n\n        :param name: The name of the new variable.\n        :type name: str\n        :param specification: The type of the variable.\n        :type specification: Type\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Abstraction(TermParameter(name, specification), suffix))\n\n        self._result = new_result\n        return self\n\n    def parameter_constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n        \"\"\"\n        Constraint on the previously defined parameter variables.\n\n        :param constraint: A constraint deciding, if the currently chosen parameter values are valid.\n            The values of variables are passed by a dictionary, where the keys are the names of the\n            parameter variables and the values are the corresponding values.\n        :type constraint: Callable[[Mapping[str, Any]], bool]\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Implication(Predicate(constraint, True), suffix))\n\n        self._result = new_result\n        return self\n\n    def constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n        \"\"\"\n        Constraint on the previously defined parameter variables and argument variables.\n\n        :param constraint: A constraint deciding, if the currently chosen values are valid.\n            The values of variables are passed by a dictionary, where the keys are the names of the\n            variables and the values are the corresponding values.\n        :type constraint: Callable[[Mapping[str, Any]], bool]\n        :return: The DSL object.\n        :rtype: DSL\n        \"\"\"\n\n        def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n            return result(Implication(Predicate(constraint, False), suffix))\n\n        self._result = new_result\n        return self\n\n    def suffix(self, suffix: Type) -&gt; Specification:\n        \"\"\"\n        Constructs the final specification wrapping the given `Type` `suffix`.\n\n        :param suffix: The wrapped type.\n        :type suffix: Type\n        :return: The constructed specification.\n        :rtype: Abstraction | Type\n        \"\"\"\n        return self._result(suffix)\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the DSL object</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the DSL object\n    \"\"\"\n\n    self._result: Callable[[Specification], Specification] = lambda suffix: suffix\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.argument","title":"<code>argument(name: str, specification: Type) -&gt; DSL</code>","text":"<p>Introduce a new variable.</p> <p><code>group</code> is a <code>Type</code>, and an instance will be generated for each tree, satisfying the specification given by the type. Since this can only be done in the enumeration step, you can only use these variables in predicates, that themselves belong to variables whose <code>group</code> is a <code>Type</code>.</p> <p>:param name: The name of the new variable. :type name: str :param specification: The type of the variable. :type specification: Type :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def argument(self, name: str, specification: Type) -&gt; DSL:\n    \"\"\"\n    Introduce a new variable.\n\n    `group` is a `Type`, and an instance will be generated for each tree, satisfying\n    the specification given by the type. Since this can only be done in the enumeration step,\n    you can only use these variables in predicates, that themselves belong to variables whose `group` is a `Type`.\n\n    :param name: The name of the new variable.\n    :type name: str\n    :param specification: The type of the variable.\n    :type specification: Type\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Abstraction(TermParameter(name, specification), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.constraint","title":"<code>constraint(constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL</code>","text":"<p>Constraint on the previously defined parameter variables and argument variables.</p> <p>:param constraint: A constraint deciding, if the currently chosen values are valid.     The values of variables are passed by a dictionary, where the keys are the names of the     variables and the values are the corresponding values. :type constraint: Callable[[Mapping[str, Any]], bool] :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n    \"\"\"\n    Constraint on the previously defined parameter variables and argument variables.\n\n    :param constraint: A constraint deciding, if the currently chosen values are valid.\n        The values of variables are passed by a dictionary, where the keys are the names of the\n        variables and the values are the corresponding values.\n    :type constraint: Callable[[Mapping[str, Any]], bool]\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Implication(Predicate(constraint, False), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.parameter","title":"<code>parameter(name: str, group: str, candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None) -&gt; DSL</code>","text":"<p>Introduce a new parameter variable.</p> <p><code>group</code> is a string, and an instance of this specification will be generated for each valid literal in the corresponding literal group. You can use this variable as Var(name) in all <code>Type</code>s, after the introduction and in all predicates. Optionally, you can specify a sequence of candidate values, that will be used to generate the literals. This sequence is parameterized by the values of previously defined literal variables. This is useful, if you want to restrict the values of a variable to a subset of the values in the corresponding literal group.</p> <p>:param name: The name of the new variable. :type name: str :param group: The group of the variable. :type group: str :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals. :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def parameter(  #\n    self,\n    name: str,\n    group: str,\n    candidates: Callable[[dict[str, Any]], Sequence[Any]] | None = None,\n) -&gt; DSL:\n    \"\"\"\n    Introduce a new parameter variable.\n\n    `group` is a string, and an instance of this specification will be generated\n    for each valid literal in the corresponding literal group.\n    You can use this variable as Var(name) in all `Type`s, after the introduction\n    and in all predicates.\n    Optionally, you can specify a sequence of candidate values, that will be used to generate\n    the literals. This sequence is parameterized by the values of previously\n    defined literal variables. This is useful, if you want to restrict the values of a variable\n    to a subset of the values in the corresponding literal group.\n\n    :param name: The name of the new variable.\n    :type name: str\n    :param group: The group of the variable.\n    :type group: str\n    :param candidates: Parameterized sequence of candidate values, that will be used to generate the literals.\n    :type candidates: Callable[[dict[str, Any]], Sequence[Any]] | None\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Abstraction(LiteralParameter(name, group, candidates), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.parameter_constraint","title":"<code>parameter_constraint(constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL</code>","text":"<p>Constraint on the previously defined parameter variables.</p> <p>:param constraint: A constraint deciding, if the currently chosen parameter values are valid.     The values of variables are passed by a dictionary, where the keys are the names of the     parameter variables and the values are the corresponding values. :type constraint: Callable[[Mapping[str, Any]], bool] :return: The DSL object. :rtype: DSL</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def parameter_constraint(self, constraint: Callable[[Mapping[str, Any]], bool]) -&gt; DSL:\n    \"\"\"\n    Constraint on the previously defined parameter variables.\n\n    :param constraint: A constraint deciding, if the currently chosen parameter values are valid.\n        The values of variables are passed by a dictionary, where the keys are the names of the\n        parameter variables and the values are the corresponding values.\n    :type constraint: Callable[[Mapping[str, Any]], bool]\n    :return: The DSL object.\n    :rtype: DSL\n    \"\"\"\n\n    def new_result(suffix: Specification, result=self._result) -&gt; Specification:\n        return result(Implication(Predicate(constraint, True), suffix))\n\n    self._result = new_result\n    return self\n</code></pre>"},{"location":"reference/cosy/dsl/#cosy.dsl.DSL.suffix","title":"<code>suffix(suffix: Type) -&gt; Specification</code>","text":"<p>Constructs the final specification wrapping the given <code>Type</code> <code>suffix</code>.</p> <p>:param suffix: The wrapped type. :type suffix: Type :return: The constructed specification. :rtype: Abstraction | Type</p> Source code in <code>src/cosy/dsl.py</code> <pre><code>def suffix(self, suffix: Type) -&gt; Specification:\n    \"\"\"\n    Constructs the final specification wrapping the given `Type` `suffix`.\n\n    :param suffix: The wrapped type.\n    :type suffix: Type\n    :return: The constructed specification.\n    :rtype: Abstraction | Type\n    \"\"\"\n    return self._result(suffix)\n</code></pre>"},{"location":"reference/cosy/inspector/","title":"inspector","text":""},{"location":"reference/cosy/inspector/#cosy.inspector","title":"<code>inspector</code>","text":"<p>Auxiliary functions for inspecting the specification. The method <code>inspect</code> analyses the given  component specifications, parameter space, and taxonomy, and provides info, warnings, and reports errors if any.</p>"},{"location":"reference/cosy/inspector/#cosy.inspector.C","title":"<code>C = TypeVar('C', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/inspector/#cosy.inspector.Inspector","title":"<code>Inspector</code>","text":"<p>Inspector class for analyzing component specifications, parameter space, and taxonomy.</p> Source code in <code>src/cosy/inspector.py</code> <pre><code>class Inspector:\n    \"\"\"Inspector class for analyzing component specifications, parameter space, and taxonomy.\"\"\"\n\n    _logger: logging.Logger\n\n    def __init__(self, logger=None):\n        if logger is None:\n            self._logger = logging.getLogger(__name__)\n            self._logger.setLevel(logging.DEBUG)\n            # handler = logging.StreamHandler()\n            # handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))\n            # self._logger.addHandler(handler)\n        else:\n            self._logger = logger\n\n    @staticmethod\n    def _constructors(ty: Type) -&gt; set[str]:\n        \"\"\"\n        Get the constructors of a type.\n        \"\"\"\n        constructors = set()\n        stack: deque[Type] = deque([ty])\n        while stack:\n            match stack.pop():\n                case Intersection(l, r):\n                    stack.extend((l, r))\n                case Arrow(src, tgt):\n                    stack.extend((src, tgt))\n                case Constructor(name, arg):\n                    constructors.add(name)\n                    stack.append(arg)\n\n        return constructors\n\n    def inspect(\n        self,\n        component_specifications: Mapping[C, Specification],\n        parameter_space: ParameterSpace | None = None,\n        taxonomy: Taxonomy | None = None,\n    ):\n        \"\"\"\n        Inspect the component specifications, parameter space, and taxonomy.\n        A `ValueError` is raised if the specifications are not well-formed, which includes:\n        - a component has two parameters/arguments with the same name (shadowing)\n        - a parameter name is used in the specification of a component but not abstracted via a parameter\n        - a group is used in a parameter but not defined in the parameter space\n\n        An info is logged if:\n        - a name is bound to different groups in different components\n        - a parameter is abstracted but not used in the specification (caveat: constraints cannot be checked)\n        - a group is not used in any component\n        - a concept is used only in one component\n        - a concept in the taxonomy is not used in any component\n        \"\"\"\n\n        if parameter_space is None:\n            parameter_space = {}\n\n        if taxonomy is None:\n            taxonomy = {}\n\n        all_groups: set[tuple[str, str | Type]] = set()\n        all_constructors: list[set[str]] = []\n\n        for specification in component_specifications.values():\n            prefix: list[LiteralParameter | TermParameter] = []\n            # mapping from variable names to groups\n            groups: dict[str, str | Type] = {}\n            # set of parameter names occurring in bodies\n            parameter_names: set[str] = set()\n            parameterized_type = specification\n            # set of constructors occurring in the specification\n            constructors: set[str] = set()\n\n            while not isinstance(parameterized_type, Type):\n                if isinstance(parameterized_type, Abstraction):\n                    param = parameterized_type.parameter\n                    if isinstance(param, LiteralParameter | TermParameter):\n                        prefix.append(param)\n                        if param.name in groups:\n                            # check if parameter names are unique\n                            msg = f\"Duplicate name: {param.name}\"\n                            raise ValueError(msg)\n                        groups[param.name] = param.group\n                        for n, g in all_groups:\n                            if n == param.name and g != param.group:\n                                self._logger.info(\n                                    \"%s is used both as %s and %s\",\n                                    param.name,\n                                    param.group,\n                                    g,\n                                )\n                        all_groups.add((param.name, param.group))\n                    if isinstance(param, LiteralParameter) and param.group not in parameter_space:\n                        # check if group is defined in the parameter space\n                        msg = f\"Group {param.group} is not defined in the parameter space\"\n                        raise ValueError(msg)\n                    if isinstance(param, TermParameter):\n                        parameter_names.update(param.group.free_vars)\n                        constructors.update(Inspector._constructors(param.group))\n                    parameterized_type = parameterized_type.body\n                elif isinstance(parameterized_type, Implication):\n                    parameterized_type = parameterized_type.body\n\n            parameter_names.update(parameterized_type.free_vars)\n            constructors.update(Inspector._constructors(parameterized_type))\n            all_constructors.append(constructors)\n            # check if every variable in the body is abstracted\n            for var in parameter_names:\n                if var not in groups:\n                    msg = f\"Variable {var} is not abstracted via a parameter\"\n                    raise ValueError(msg)\n\n            # check if every abstracted variable is used\n            for var, group in groups.items():\n                if isinstance(group, str) and var not in parameter_names:\n                    self._logger.info(\"Variable %s is abstracted via a parameter but not used\", var)\n\n        all_group_names = {g for n, g in all_groups if isinstance(g, str)}\n\n        # check if every group is used\n        for group in parameter_space:\n            if group not in all_group_names:\n                self._logger.info(\"Group %s is not used in any component\", group)\n\n        # check is some constructor is used only in one component\n        for constructors in all_constructors:\n            for constructor in constructors:\n                if sum(1 for cs in all_constructors if constructor in cs) == 1:\n                    self._logger.info(\"Concept %s is used in only one component\", constructor)\n\n        # check if every concept in the taxonomy is used\n        for name, subtypes in taxonomy.items():\n            for c in chain([name], subtypes):\n                if c not in set.union(*all_constructors):\n                    self._logger.info(\"Concept %s is not used in any component\", c)\n</code></pre>"},{"location":"reference/cosy/inspector/#cosy.inspector.Inspector.__init__","title":"<code>__init__(logger=None)</code>","text":"Source code in <code>src/cosy/inspector.py</code> <pre><code>def __init__(self, logger=None):\n    if logger is None:\n        self._logger = logging.getLogger(__name__)\n        self._logger.setLevel(logging.DEBUG)\n        # handler = logging.StreamHandler()\n        # handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))\n        # self._logger.addHandler(handler)\n    else:\n        self._logger = logger\n</code></pre>"},{"location":"reference/cosy/inspector/#cosy.inspector.Inspector.inspect","title":"<code>inspect(component_specifications: Mapping[C, Specification], parameter_space: ParameterSpace | None = None, taxonomy: Taxonomy | None = None)</code>","text":"<p>Inspect the component specifications, parameter space, and taxonomy. A <code>ValueError</code> is raised if the specifications are not well-formed, which includes: - a component has two parameters/arguments with the same name (shadowing) - a parameter name is used in the specification of a component but not abstracted via a parameter - a group is used in a parameter but not defined in the parameter space</p> <p>An info is logged if: - a name is bound to different groups in different components - a parameter is abstracted but not used in the specification (caveat: constraints cannot be checked) - a group is not used in any component - a concept is used only in one component - a concept in the taxonomy is not used in any component</p> Source code in <code>src/cosy/inspector.py</code> <pre><code>def inspect(\n    self,\n    component_specifications: Mapping[C, Specification],\n    parameter_space: ParameterSpace | None = None,\n    taxonomy: Taxonomy | None = None,\n):\n    \"\"\"\n    Inspect the component specifications, parameter space, and taxonomy.\n    A `ValueError` is raised if the specifications are not well-formed, which includes:\n    - a component has two parameters/arguments with the same name (shadowing)\n    - a parameter name is used in the specification of a component but not abstracted via a parameter\n    - a group is used in a parameter but not defined in the parameter space\n\n    An info is logged if:\n    - a name is bound to different groups in different components\n    - a parameter is abstracted but not used in the specification (caveat: constraints cannot be checked)\n    - a group is not used in any component\n    - a concept is used only in one component\n    - a concept in the taxonomy is not used in any component\n    \"\"\"\n\n    if parameter_space is None:\n        parameter_space = {}\n\n    if taxonomy is None:\n        taxonomy = {}\n\n    all_groups: set[tuple[str, str | Type]] = set()\n    all_constructors: list[set[str]] = []\n\n    for specification in component_specifications.values():\n        prefix: list[LiteralParameter | TermParameter] = []\n        # mapping from variable names to groups\n        groups: dict[str, str | Type] = {}\n        # set of parameter names occurring in bodies\n        parameter_names: set[str] = set()\n        parameterized_type = specification\n        # set of constructors occurring in the specification\n        constructors: set[str] = set()\n\n        while not isinstance(parameterized_type, Type):\n            if isinstance(parameterized_type, Abstraction):\n                param = parameterized_type.parameter\n                if isinstance(param, LiteralParameter | TermParameter):\n                    prefix.append(param)\n                    if param.name in groups:\n                        # check if parameter names are unique\n                        msg = f\"Duplicate name: {param.name}\"\n                        raise ValueError(msg)\n                    groups[param.name] = param.group\n                    for n, g in all_groups:\n                        if n == param.name and g != param.group:\n                            self._logger.info(\n                                \"%s is used both as %s and %s\",\n                                param.name,\n                                param.group,\n                                g,\n                            )\n                    all_groups.add((param.name, param.group))\n                if isinstance(param, LiteralParameter) and param.group not in parameter_space:\n                    # check if group is defined in the parameter space\n                    msg = f\"Group {param.group} is not defined in the parameter space\"\n                    raise ValueError(msg)\n                if isinstance(param, TermParameter):\n                    parameter_names.update(param.group.free_vars)\n                    constructors.update(Inspector._constructors(param.group))\n                parameterized_type = parameterized_type.body\n            elif isinstance(parameterized_type, Implication):\n                parameterized_type = parameterized_type.body\n\n        parameter_names.update(parameterized_type.free_vars)\n        constructors.update(Inspector._constructors(parameterized_type))\n        all_constructors.append(constructors)\n        # check if every variable in the body is abstracted\n        for var in parameter_names:\n            if var not in groups:\n                msg = f\"Variable {var} is not abstracted via a parameter\"\n                raise ValueError(msg)\n\n        # check if every abstracted variable is used\n        for var, group in groups.items():\n            if isinstance(group, str) and var not in parameter_names:\n                self._logger.info(\"Variable %s is abstracted via a parameter but not used\", var)\n\n    all_group_names = {g for n, g in all_groups if isinstance(g, str)}\n\n    # check if every group is used\n    for group in parameter_space:\n        if group not in all_group_names:\n            self._logger.info(\"Group %s is not used in any component\", group)\n\n    # check is some constructor is used only in one component\n    for constructors in all_constructors:\n        for constructor in constructors:\n            if sum(1 for cs in all_constructors if constructor in cs) == 1:\n                self._logger.info(\"Concept %s is used in only one component\", constructor)\n\n    # check if every concept in the taxonomy is used\n    for name, subtypes in taxonomy.items():\n        for c in chain([name], subtypes):\n            if c not in set.union(*all_constructors):\n                self._logger.info(\"Concept %s is not used in any component\", c)\n</code></pre>"},{"location":"reference/cosy/solution_space/","title":"solution_space","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space","title":"<code>solution_space</code>","text":"<p>Solution space given by a logic program.</p>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.Argument","title":"<code>Argument = ConstantArgument[T, G] | NonTerminalArgument[NT]</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.G","title":"<code>G = TypeVar('G', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.NT","title":"<code>NT = TypeVar('NT', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.T","title":"<code>T = TypeVar('T', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.ConstantArgument","title":"<code>ConstantArgument</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>@dataclass(frozen=True)\nclass ConstantArgument(Generic[T, G]):\n    name: str\n    value: T\n    origin: G\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.ConstantArgument.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.ConstantArgument.origin","title":"<code>origin: G</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.ConstantArgument.value","title":"<code>value: T</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.ConstantArgument.__init__","title":"<code>__init__(name: str, value: T, origin: G) -&gt; None</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.NonTerminalArgument","title":"<code>NonTerminalArgument</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>@dataclass(frozen=True)\nclass NonTerminalArgument(Generic[NT]):\n    name: str | None\n    origin: NT\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.NonTerminalArgument.name","title":"<code>name: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.NonTerminalArgument.origin","title":"<code>origin: NT</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.NonTerminalArgument.__init__","title":"<code>__init__(name: str | None, origin: NT) -&gt; None</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule","title":"<code>RHSRule</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>@dataclass(frozen=True)\nclass RHSRule(Generic[NT, T, G]):\n    arguments: tuple[Argument, ...]\n    predicates: tuple[Callable[[dict[str, Any]], bool], ...]\n    terminal: T\n\n    @property\n    def non_terminals(self) -&gt; frozenset[NT]:\n        \"\"\"Set of non-terminals occurring in the body of the rule.\"\"\"\n        return frozenset(arg.origin for arg in self.arguments if isinstance(arg, NonTerminalArgument))\n\n    @property\n    def literal_substitution(self):\n        return {n.name: n.value for n in self.arguments if isinstance(n, ConstantArgument)}\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.arguments","title":"<code>arguments: tuple[Argument, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.literal_substitution","title":"<code>literal_substitution</code>  <code>property</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.non_terminals","title":"<code>non_terminals: frozenset[NT]</code>  <code>property</code>","text":"<p>Set of non-terminals occurring in the body of the rule.</p>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.predicates","title":"<code>predicates: tuple[Callable[[dict[str, Any]], bool], ...]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.terminal","title":"<code>terminal: T</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.RHSRule.__init__","title":"<code>__init__(arguments: tuple[Argument, ...], predicates: tuple[Callable[[dict[str, Any]], bool], ...], terminal: T) -&gt; None</code>","text":""},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace","title":"<code>SolutionSpace</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>class SolutionSpace(Generic[NT, T, G]):\n    _rules: defaultdict[NT, deque[RHSRule[NT, T, G]]]\n\n    def __init__(self, rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None:\n        if rules is None:\n            rules = defaultdict(deque)\n        self._rules = defaultdict(deque, rules)\n\n    def get(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None:\n        return self._rules.get(nonterminal)\n\n    def __getitem__(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]:\n        return self._rules[nonterminal]\n\n    def nonterminals(self) -&gt; Iterable[NT]:\n        return self._rules.keys()\n\n    def as_tuples(self) -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]:\n        return self._rules.items()\n\n    def add_rule(\n        self,\n        nonterminal: NT,\n        terminal: T,\n        arguments: tuple[Argument, ...],\n        predicates: tuple[Callable[[dict[str, Any]], bool], ...],\n    ) -&gt; None:\n        self._rules[nonterminal].append(RHSRule(arguments, predicates, terminal))\n\n    def show(self) -&gt; str:\n        return \"\\n\".join(\n            f\"{nt!s} ~&gt; {' | '.join([str(subrule) for subrule in rule])}\" for nt, rule in self._rules.items()\n        )\n\n    def prune(self) -&gt; SolutionSpace[NT, T, G]:\n        \"\"\"Keep only productive rules.\"\"\"\n\n        ground_types: set[NT] = set()\n        queue: set[NT] = set()\n        inverse_grammar: dict[NT, set[tuple[NT, frozenset[NT]]]] = defaultdict(set)\n\n        for n, exprs in self._rules.items():\n            for expr in exprs:\n                non_terminals = expr.non_terminals\n                for m in non_terminals:\n                    inverse_grammar[m].add((n, non_terminals))\n                if not non_terminals:\n                    queue.add(n)\n\n        while queue:\n            n = queue.pop()\n            if n not in ground_types:\n                ground_types.add(n)\n                for m, non_terminals in inverse_grammar[n]:\n                    if m not in ground_types and all(t in ground_types for t in non_terminals):\n                        queue.add(m)\n\n        return SolutionSpace[NT, T, G](\n            defaultdict(\n                deque,\n                {\n                    target: deque(\n                        possibility\n                        for possibility in self._rules[target]\n                        if all(t in ground_types for t in possibility.non_terminals)\n                    )\n                    for target in ground_types\n                },\n            )\n        )\n\n    def _enumerate_tree_vectors(\n        self,\n        non_terminals: Sequence[NT | None],\n        existing_terms: Mapping[NT, set[Tree[T]]],\n        nt_term: tuple[NT, Tree[T]] | None = None,\n    ) -&gt; Iterable[tuple[Tree[T] | None, ...]]:\n        \"\"\"Enumerate possible term vectors for a given list of non-terminals and existing terms. Use nt_term at least once (if given).\"\"\"\n        if nt_term is None:\n            yield from product(*([n] if n is None else existing_terms[n] for n in non_terminals))\n        else:\n            nt, term = nt_term\n            for i, n in enumerate(non_terminals):\n                if n == nt:\n                    arg_lists: Iterable[Iterable[Tree[T] | None]] = (\n                        [None] if m is None else [term] if i == j else existing_terms[m]\n                        for j, m in enumerate(non_terminals)\n                    )\n                    yield from product(*arg_lists)\n\n    def _generate_new_trees(\n        self,\n        rule: RHSRule[NT, T, G],\n        existing_terms: Mapping[NT, set[Tree[T]]],\n        max_count: int | None = None,\n        nt_old_term: tuple[NT, Tree[T]] | None = None,\n    ) -&gt; set[Tree[T]]:\n        # Genererate new terms for rule `rule` from existing terms up to `max_count`\n        # the term `old_term` should be a subterm of all resulting terms, at a position, that corresponds to `nt`\n\n        output_set: set[Tree[T]] = set()\n        if max_count == 0:\n            return output_set\n\n        named_non_terminals = [\n            a.origin if isinstance(a, NonTerminalArgument) and a.name is not None else None for a in rule.arguments\n        ]\n        unnamed_non_terminals = [\n            a.origin if isinstance(a, NonTerminalArgument) and a.name is None else None for a in rule.arguments\n        ]\n        literal_arguments = [Tree(a.value, ()) if isinstance(a, ConstantArgument) else None for a in rule.arguments]\n\n        def interleave(\n            parameters: Sequence[Tree[T] | None],\n            literal_arguments: Sequence[Tree[T] | None],\n            arguments: Sequence[Tree[T] | None],\n        ) -&gt; Iterable[Tree[T]]:\n            \"\"\"Interleave parameters, literal arguments and arguments.\"\"\"\n            for parameter, literal_argument, argument in zip(parameters, literal_arguments, arguments, strict=True):\n                if parameter is not None:\n                    yield parameter\n                elif literal_argument is not None:\n                    yield literal_argument\n                elif argument is not None:\n                    yield argument\n                else:\n                    msg = \"All arguments of interleave are None\"\n                    raise ValueError(msg)\n\n        def construct_tree(\n            rule: RHSRule[NT, T, G],\n            parameters: Sequence[Tree[T] | None],\n            literal_arguments: Sequence[Tree[T] | None],\n            arguments: Sequence[Tree[T] | None],\n        ) -&gt; Tree[T]:\n            \"\"\"Construct a new tree from the rule and the given specific arguments.\"\"\"\n            return Tree(\n                rule.terminal,\n                tuple(interleave(parameters, literal_arguments, arguments)),\n            )\n\n        def specific_substitution(parameters):\n            return {\n                a.name: p\n                for p, a in zip(parameters, rule.arguments, strict=True)\n                if isinstance(a, NonTerminalArgument) and a.name is not None\n            } | rule.literal_substitution\n\n        def valid_parameters(\n            nt_term: tuple[NT, Tree[T]] | None,\n        ) -&gt; Iterable[tuple[Tree[T] | None, ...]]:\n            \"\"\"Enumerate all valid parameters for the rule.\"\"\"\n            for parameters in self._enumerate_tree_vectors(named_non_terminals, existing_terms, nt_term):\n                substitution = specific_substitution(parameters)\n                if all(predicate(substitution) for predicate in rule.predicates):\n                    yield parameters\n\n        for parameters in valid_parameters(nt_old_term):\n            for arguments in self._enumerate_tree_vectors(unnamed_non_terminals, existing_terms):\n                output_set.add(construct_tree(rule, parameters, literal_arguments, arguments))\n                if max_count is not None and len(output_set) &gt;= max_count:\n                    return output_set\n\n        if nt_old_term is not None:\n            all_parameters: deque[tuple[Tree[T] | None, ...]] | None = None\n            for arguments in self._enumerate_tree_vectors(unnamed_non_terminals, existing_terms):\n                all_parameters = all_parameters if all_parameters is not None else deque(valid_parameters(None))\n                for parameters in all_parameters:\n                    output_set.add(construct_tree(rule, parameters, literal_arguments, arguments))\n                    if max_count is not None and len(output_set) &gt;= max_count:\n                        return output_set\n        return output_set\n\n    def enumerate_trees(\n        self,\n        start: NT,\n        max_count: int | None = None,\n        max_bucket_size: int | None = None,\n    ) -&gt; Iterable[Tree[T]]:\n        \"\"\"\n        Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.\n        \"\"\"\n        if start not in self.nonterminals():\n            return\n\n        queues: dict[NT, PriorityQueue[Tree[T]]] = {n: PriorityQueue() for n in self.nonterminals()}\n        existing_terms: dict[NT, set[Tree[T]]] = {n: set() for n in self.nonterminals()}\n        inverse_grammar: dict[NT, deque[tuple[NT, RHSRule[NT, T, G]]]] = {n: deque() for n in self.nonterminals()}\n        all_results: set[Tree[T]] = set()\n\n        for n, exprs in self._rules.items():\n            for expr in exprs:\n                if expr.non_terminals.issubset(self.nonterminals()):\n                    for m in expr.non_terminals:\n                        if m in self.nonterminals():\n                            inverse_grammar[m].append((n, expr))\n                    for new_term in self._generate_new_trees(expr, existing_terms):\n                        queues[n].put(new_term)\n                        if n == start and new_term not in all_results:\n                            if max_count is not None and len(all_results) &gt;= max_count:\n                                return\n                            yield new_term\n                            all_results.add(new_term)\n\n        current_bucket_size = 1\n\n        while (max_bucket_size is None or current_bucket_size &lt;= max_bucket_size) and any(\n            not queue.empty() for queue in queues.values()\n        ):\n            non_terminals = {n for n in self.nonterminals() if not queues[n].empty()}\n\n            while non_terminals:\n                n = non_terminals.pop()\n                results = existing_terms[n]\n                while len(results) &lt; current_bucket_size and not queues[n].empty():\n                    term = queues[n].get()\n                    if term in results:\n                        continue\n                    results.add(term)\n                    for m, expr in inverse_grammar[n]:\n                        if len(existing_terms[m]) &lt; current_bucket_size:\n                            non_terminals.add(m)\n                        if m == start:\n                            for new_term in self._generate_new_trees(expr, existing_terms, max_count, (n, term)):\n                                if new_term not in all_results:\n                                    if max_count is not None and len(all_results) &gt;= max_count:\n                                        return\n                                    yield new_term\n                                    all_results.add(new_term)\n                                    queues[start].put(new_term)\n                        else:\n                            for new_term in self._generate_new_trees(expr, existing_terms, max_bucket_size, (n, term)):\n                                queues[m].put(new_term)\n            current_bucket_size += 1\n        return\n\n    def contains_tree(self, start: NT, tree: Tree[T]) -&gt; bool:\n        \"\"\"Check if the solution space contains a given `tree` derivable from `start`.\"\"\"\n        if start not in self.nonterminals():\n            return False\n\n        stack: deque[tuple | Callable] = deque([(start, tree)])\n        results: deque[bool] = deque()\n\n        def get_inputs(count: int) -&gt; Generator[bool]:\n            for _ in range(count):\n                yield results.pop()\n            return\n\n        while stack:\n            task = stack.pop()\n            if isinstance(task, tuple):\n                nt, tree = task\n                relevant_rhss = [\n                    rhs\n                    for rhs in self._rules[nt]\n                    if len(rhs.arguments) == len(tree.children)\n                    and rhs.terminal == tree.root\n                    and all(\n                        argument.value == child.root and len(child.children) == 0\n                        for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                        if isinstance(argument, ConstantArgument)\n                    )\n                ]\n\n                # if there is a relevant rule containing only TerminalArgument which are equal to the children of the tree\n                if any(\n                    all(isinstance(argument, ConstantArgument) for argument in rhs.arguments) for rhs in relevant_rhss\n                ):\n                    results.append(True)\n                    continue\n\n                # disjunction of the results for individual rules\n                def or_inputs(count: int = len(relevant_rhss)) -&gt; None:\n                    results.append(any(get_inputs(count)))\n\n                stack.append(or_inputs)\n\n                for rhs in relevant_rhss:\n                    substitution = {\n                        argument.name: child.root if isinstance(argument, ConstantArgument) else child\n                        for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                        if argument.name is not None\n                    }\n\n                    # conjunction of the results for individual arguments in the rule\n                    def and_inputs(\n                        count: int = sum(1 for argument in rhs.arguments if isinstance(argument, NonTerminalArgument)),\n                        substitution: dict[str, Any] = substitution,\n                        predicates=rhs.predicates,\n                    ) -&gt; None:\n                        results.append(\n                            all(get_inputs(count)) and all(predicate(substitution) for predicate in predicates)\n                        )\n\n                    stack.append(and_inputs)\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True):\n                        if isinstance(argument, NonTerminalArgument):\n                            stack.append((argument.origin, child))\n            elif isinstance(task, FunctionType):\n                # task is a function to execute\n                task()\n        return results.pop()\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.__getitem__","title":"<code>__getitem__(nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def __getitem__(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]]:\n    return self._rules[nonterminal]\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.__init__","title":"<code>__init__(rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def __init__(self, rules: dict[NT, deque[RHSRule[NT, T, G]]] | None = None) -&gt; None:\n    if rules is None:\n        rules = defaultdict(deque)\n    self._rules = defaultdict(deque, rules)\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.add_rule","title":"<code>add_rule(nonterminal: NT, terminal: T, arguments: tuple[Argument, ...], predicates: tuple[Callable[[dict[str, Any]], bool], ...]) -&gt; None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def add_rule(\n    self,\n    nonterminal: NT,\n    terminal: T,\n    arguments: tuple[Argument, ...],\n    predicates: tuple[Callable[[dict[str, Any]], bool], ...],\n) -&gt; None:\n    self._rules[nonterminal].append(RHSRule(arguments, predicates, terminal))\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.as_tuples","title":"<code>as_tuples() -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def as_tuples(self) -&gt; Iterable[tuple[NT, deque[RHSRule[NT, T, G]]]]:\n    return self._rules.items()\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.contains_tree","title":"<code>contains_tree(start: NT, tree: Tree[T]) -&gt; bool</code>","text":"<p>Check if the solution space contains a given <code>tree</code> derivable from <code>start</code>.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def contains_tree(self, start: NT, tree: Tree[T]) -&gt; bool:\n    \"\"\"Check if the solution space contains a given `tree` derivable from `start`.\"\"\"\n    if start not in self.nonterminals():\n        return False\n\n    stack: deque[tuple | Callable] = deque([(start, tree)])\n    results: deque[bool] = deque()\n\n    def get_inputs(count: int) -&gt; Generator[bool]:\n        for _ in range(count):\n            yield results.pop()\n        return\n\n    while stack:\n        task = stack.pop()\n        if isinstance(task, tuple):\n            nt, tree = task\n            relevant_rhss = [\n                rhs\n                for rhs in self._rules[nt]\n                if len(rhs.arguments) == len(tree.children)\n                and rhs.terminal == tree.root\n                and all(\n                    argument.value == child.root and len(child.children) == 0\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                    if isinstance(argument, ConstantArgument)\n                )\n            ]\n\n            # if there is a relevant rule containing only TerminalArgument which are equal to the children of the tree\n            if any(\n                all(isinstance(argument, ConstantArgument) for argument in rhs.arguments) for rhs in relevant_rhss\n            ):\n                results.append(True)\n                continue\n\n            # disjunction of the results for individual rules\n            def or_inputs(count: int = len(relevant_rhss)) -&gt; None:\n                results.append(any(get_inputs(count)))\n\n            stack.append(or_inputs)\n\n            for rhs in relevant_rhss:\n                substitution = {\n                    argument.name: child.root if isinstance(argument, ConstantArgument) else child\n                    for argument, child in zip(rhs.arguments, tree.children, strict=True)\n                    if argument.name is not None\n                }\n\n                # conjunction of the results for individual arguments in the rule\n                def and_inputs(\n                    count: int = sum(1 for argument in rhs.arguments if isinstance(argument, NonTerminalArgument)),\n                    substitution: dict[str, Any] = substitution,\n                    predicates=rhs.predicates,\n                ) -&gt; None:\n                    results.append(\n                        all(get_inputs(count)) and all(predicate(substitution) for predicate in predicates)\n                    )\n\n                stack.append(and_inputs)\n                for argument, child in zip(rhs.arguments, tree.children, strict=True):\n                    if isinstance(argument, NonTerminalArgument):\n                        stack.append((argument.origin, child))\n        elif isinstance(task, FunctionType):\n            # task is a function to execute\n            task()\n    return results.pop()\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.enumerate_trees","title":"<code>enumerate_trees(start: NT, max_count: int | None = None, max_bucket_size: int | None = None) -&gt; Iterable[Tree[T]]</code>","text":"<p>Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def enumerate_trees(\n    self,\n    start: NT,\n    max_count: int | None = None,\n    max_bucket_size: int | None = None,\n) -&gt; Iterable[Tree[T]]:\n    \"\"\"\n    Enumerate terms as an iterator efficiently - all terms are enumerated, no guaranteed term order.\n    \"\"\"\n    if start not in self.nonterminals():\n        return\n\n    queues: dict[NT, PriorityQueue[Tree[T]]] = {n: PriorityQueue() for n in self.nonterminals()}\n    existing_terms: dict[NT, set[Tree[T]]] = {n: set() for n in self.nonterminals()}\n    inverse_grammar: dict[NT, deque[tuple[NT, RHSRule[NT, T, G]]]] = {n: deque() for n in self.nonterminals()}\n    all_results: set[Tree[T]] = set()\n\n    for n, exprs in self._rules.items():\n        for expr in exprs:\n            if expr.non_terminals.issubset(self.nonterminals()):\n                for m in expr.non_terminals:\n                    if m in self.nonterminals():\n                        inverse_grammar[m].append((n, expr))\n                for new_term in self._generate_new_trees(expr, existing_terms):\n                    queues[n].put(new_term)\n                    if n == start and new_term not in all_results:\n                        if max_count is not None and len(all_results) &gt;= max_count:\n                            return\n                        yield new_term\n                        all_results.add(new_term)\n\n    current_bucket_size = 1\n\n    while (max_bucket_size is None or current_bucket_size &lt;= max_bucket_size) and any(\n        not queue.empty() for queue in queues.values()\n    ):\n        non_terminals = {n for n in self.nonterminals() if not queues[n].empty()}\n\n        while non_terminals:\n            n = non_terminals.pop()\n            results = existing_terms[n]\n            while len(results) &lt; current_bucket_size and not queues[n].empty():\n                term = queues[n].get()\n                if term in results:\n                    continue\n                results.add(term)\n                for m, expr in inverse_grammar[n]:\n                    if len(existing_terms[m]) &lt; current_bucket_size:\n                        non_terminals.add(m)\n                    if m == start:\n                        for new_term in self._generate_new_trees(expr, existing_terms, max_count, (n, term)):\n                            if new_term not in all_results:\n                                if max_count is not None and len(all_results) &gt;= max_count:\n                                    return\n                                yield new_term\n                                all_results.add(new_term)\n                                queues[start].put(new_term)\n                    else:\n                        for new_term in self._generate_new_trees(expr, existing_terms, max_bucket_size, (n, term)):\n                            queues[m].put(new_term)\n        current_bucket_size += 1\n    return\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.get","title":"<code>get(nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def get(self, nonterminal: NT) -&gt; deque[RHSRule[NT, T, G]] | None:\n    return self._rules.get(nonterminal)\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.nonterminals","title":"<code>nonterminals() -&gt; Iterable[NT]</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def nonterminals(self) -&gt; Iterable[NT]:\n    return self._rules.keys()\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.prune","title":"<code>prune() -&gt; SolutionSpace[NT, T, G]</code>","text":"<p>Keep only productive rules.</p> Source code in <code>src/cosy/solution_space.py</code> <pre><code>def prune(self) -&gt; SolutionSpace[NT, T, G]:\n    \"\"\"Keep only productive rules.\"\"\"\n\n    ground_types: set[NT] = set()\n    queue: set[NT] = set()\n    inverse_grammar: dict[NT, set[tuple[NT, frozenset[NT]]]] = defaultdict(set)\n\n    for n, exprs in self._rules.items():\n        for expr in exprs:\n            non_terminals = expr.non_terminals\n            for m in non_terminals:\n                inverse_grammar[m].add((n, non_terminals))\n            if not non_terminals:\n                queue.add(n)\n\n    while queue:\n        n = queue.pop()\n        if n not in ground_types:\n            ground_types.add(n)\n            for m, non_terminals in inverse_grammar[n]:\n                if m not in ground_types and all(t in ground_types for t in non_terminals):\n                    queue.add(m)\n\n    return SolutionSpace[NT, T, G](\n        defaultdict(\n            deque,\n            {\n                target: deque(\n                    possibility\n                    for possibility in self._rules[target]\n                    if all(t in ground_types for t in possibility.non_terminals)\n                )\n                for target in ground_types\n            },\n        )\n    )\n</code></pre>"},{"location":"reference/cosy/solution_space/#cosy.solution_space.SolutionSpace.show","title":"<code>show() -&gt; str</code>","text":"Source code in <code>src/cosy/solution_space.py</code> <pre><code>def show(self) -&gt; str:\n    return \"\\n\".join(\n        f\"{nt!s} ~&gt; {' | '.join([str(subrule) for subrule in rule])}\" for nt, rule in self._rules.items()\n    )\n</code></pre>"},{"location":"reference/cosy/subtypes/","title":"subtypes","text":""},{"location":"reference/cosy/subtypes/#cosy.subtypes","title":"<code>subtypes</code>","text":"<p>This module provides a <code>Subtypes</code> class, which is used to check subtyping relationships between types in the intersection type system.</p>"},{"location":"reference/cosy/subtypes/#cosy.subtypes.Taxonomy","title":"<code>Taxonomy = Mapping[str, set[str]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/subtypes/#cosy.subtypes.Subtypes","title":"<code>Subtypes</code>","text":"Source code in <code>src/cosy/subtypes.py</code> <pre><code>class Subtypes:\n    def __init__(self, taxonomy: Taxonomy):\n        self.taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))\n\n    def _check_subtype_rec(\n        self,\n        subtypes: deque[Type],\n        supertype: Type,\n        groups: Mapping[str, str],\n        substitutions: Mapping[str, Literal],\n    ) -&gt; bool:\n        if supertype.is_omega:\n            return True\n        match supertype:\n            case Literal(value2, group2):\n                while subtypes:\n                    match subtypes.pop():\n                        case Literal(value1, group1):\n                            if value2 == value1 and group1 == group2:\n                                return True\n                        case Var(name1):\n                            if groups[name1] == supertype.group and substitutions[name1] == supertype.value:\n                                return True\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return False\n            case Constructor(name2, arg2):\n                casted_constr: deque[Type] = deque()\n                while subtypes:\n                    match subtypes.pop():\n                        case Constructor(name1, arg1):\n                            if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                                casted_constr.append(arg1)\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return len(casted_constr) != 0 and self._check_subtype_rec(casted_constr, arg2, groups, substitutions)\n            case Arrow(src2, tgt2):\n                casted_arr: deque[Type] = deque()\n                while subtypes:\n                    match subtypes.pop():\n                        case Arrow(src1, tgt1):\n                            if self._check_subtype_rec(deque((src2,)), src1, groups, substitutions):\n                                casted_arr.append(tgt1)\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return len(casted_arr) != 0 and self._check_subtype_rec(casted_arr, tgt2, groups, substitutions)\n            case Intersection(l, r):\n                return self._check_subtype_rec(subtypes.copy(), l, groups, substitutions) and self._check_subtype_rec(\n                    subtypes, r, groups, substitutions\n                )\n            case Var(name):\n                while subtypes:\n                    match subtypes.pop():\n                        case Literal(value, group):\n                            if groups[name] == group and substitutions[name] == value:\n                                return True\n                        case Intersection(l, r):\n                            subtypes.extend((l, r))\n                return False\n            case _:\n                msg = f\"Unsupported type in check_subtype: {supertype}\"\n                raise TypeError(msg)\n\n    def check_subtype(\n        self,\n        subtype: Type,\n        supertype: Type,\n        groups: Mapping[str, str],\n        substitutions: Mapping[str, Literal],\n    ) -&gt; bool:\n        \"\"\"Decides whether subtype &lt;= supertype with respect to intersection type subtyping.\"\"\"\n\n        return self._check_subtype_rec(deque((subtype,)), supertype, groups, substitutions)\n\n    def infer_substitution(self, subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None:\n        \"\"\"Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.\"\"\"\n\n        if subtype.is_omega:\n            return None\n\n        match subtype:\n            case Literal(value1, group1):\n                match path:\n                    case Literal(value2, group2):\n                        if value1 == value2 and group1 == group2:\n                            return {}\n            case Constructor(name1, arg1):\n                match path:\n                    case Constructor(name2, arg2):\n                        if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                            if arg2.is_omega:\n                                return {}\n                            return self.infer_substitution(arg1, arg2, groups)\n            case Arrow(src1, tgt1):\n                match path:\n                    case Arrow(src2, tgt2):\n                        substitution = self.infer_substitution(tgt1, tgt2, groups)\n                        if substitution is None:\n                            return None\n                        if all(name in substitution for name in src1.free_vars):\n                            if self.check_subtype(src2, src1, groups, substitution):\n                                return substitution\n                            return None\n                        return {}  # there are actual non-Ambiguous cases (relevant in practice?)\n            case Intersection(l, r):\n                substitution1 = self.infer_substitution(l, path, groups)\n                substitution2 = self.infer_substitution(r, path, groups)\n                if substitution1 is None:\n                    return substitution2\n                if substitution2 is None:\n                    return substitution1\n                if all(\n                    (name in substitution2 and substitution2[name] == value for name, value in substitution1.items())\n                ):\n                    return substitution1  # substitution1 included in substitution2\n                if all(\n                    (name in substitution1 and substitution1[name] == value for name, value in substitution2.items())\n                ):\n                    return substitution2  # substitution2 included in substitution1\n                return {}\n            case Var(name):\n                match path:\n                    case Literal(value2, group2):\n                        if groups[name] == group2:\n                            return {name: value2}\n            case _:\n                msg = f\"Unsupported type in infer_substitution: {subtype}\"\n                raise TypeError(msg)\n        return None\n\n    @staticmethod\n    def _reflexive_closure(env: Mapping[str, set[str]]) -&gt; dict[str, set[str]]:\n        all_types: set[str] = set(env.keys())\n        for v in env.values():\n            all_types.update(v)\n        result: dict[str, set[str]] = {subtype: {subtype}.union(env.get(subtype, set())) for subtype in all_types}\n        return result\n\n    @staticmethod\n    def _transitive_closure(env: Mapping[str, set[str]]) -&gt; dict[str, set[str]]:\n        result: dict[str, set[str]] = {subtype: supertypes.copy() for (subtype, supertypes) in env.items()}\n        has_changed = True\n\n        while has_changed:\n            has_changed = False\n            for known_supertypes in result.values():\n                for supertype in known_supertypes.copy():\n                    to_add: set[str] = {\n                        new_supertype for new_supertype in result[supertype] if new_supertype not in known_supertypes\n                    }\n                    if to_add:\n                        has_changed = True\n                    known_supertypes.update(to_add)\n\n        return result\n</code></pre>"},{"location":"reference/cosy/subtypes/#cosy.subtypes.Subtypes.taxonomy","title":"<code>taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/subtypes/#cosy.subtypes.Subtypes.__init__","title":"<code>__init__(taxonomy: Taxonomy)</code>","text":"Source code in <code>src/cosy/subtypes.py</code> <pre><code>def __init__(self, taxonomy: Taxonomy):\n    self.taxonomy = self._transitive_closure(self._reflexive_closure(taxonomy))\n</code></pre>"},{"location":"reference/cosy/subtypes/#cosy.subtypes.Subtypes.check_subtype","title":"<code>check_subtype(subtype: Type, supertype: Type, groups: Mapping[str, str], substitutions: Mapping[str, Literal]) -&gt; bool</code>","text":"<p>Decides whether subtype &lt;= supertype with respect to intersection type subtyping.</p> Source code in <code>src/cosy/subtypes.py</code> <pre><code>def check_subtype(\n    self,\n    subtype: Type,\n    supertype: Type,\n    groups: Mapping[str, str],\n    substitutions: Mapping[str, Literal],\n) -&gt; bool:\n    \"\"\"Decides whether subtype &lt;= supertype with respect to intersection type subtyping.\"\"\"\n\n    return self._check_subtype_rec(deque((subtype,)), supertype, groups, substitutions)\n</code></pre>"},{"location":"reference/cosy/subtypes/#cosy.subtypes.Subtypes.infer_substitution","title":"<code>infer_substitution(subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None</code>","text":"<p>Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.</p> Source code in <code>src/cosy/subtypes.py</code> <pre><code>def infer_substitution(self, subtype: Type, path: Type, groups: Mapping[str, str]) -&gt; dict[str, Any] | None:\n    \"\"\"Infers a unique substitution S such that S(subtype) &lt;= path where path is closed. Returns None or Ambiguous is no solution exists or multiple solutions exist respectively.\"\"\"\n\n    if subtype.is_omega:\n        return None\n\n    match subtype:\n        case Literal(value1, group1):\n            match path:\n                case Literal(value2, group2):\n                    if value1 == value2 and group1 == group2:\n                        return {}\n        case Constructor(name1, arg1):\n            match path:\n                case Constructor(name2, arg2):\n                    if name2 == name1 or name2 in self.taxonomy.get(name1, {}):\n                        if arg2.is_omega:\n                            return {}\n                        return self.infer_substitution(arg1, arg2, groups)\n        case Arrow(src1, tgt1):\n            match path:\n                case Arrow(src2, tgt2):\n                    substitution = self.infer_substitution(tgt1, tgt2, groups)\n                    if substitution is None:\n                        return None\n                    if all(name in substitution for name in src1.free_vars):\n                        if self.check_subtype(src2, src1, groups, substitution):\n                            return substitution\n                        return None\n                    return {}  # there are actual non-Ambiguous cases (relevant in practice?)\n        case Intersection(l, r):\n            substitution1 = self.infer_substitution(l, path, groups)\n            substitution2 = self.infer_substitution(r, path, groups)\n            if substitution1 is None:\n                return substitution2\n            if substitution2 is None:\n                return substitution1\n            if all(\n                (name in substitution2 and substitution2[name] == value for name, value in substitution1.items())\n            ):\n                return substitution1  # substitution1 included in substitution2\n            if all(\n                (name in substitution1 and substitution1[name] == value for name, value in substitution2.items())\n            ):\n                return substitution2  # substitution2 included in substitution1\n            return {}\n        case Var(name):\n            match path:\n                case Literal(value2, group2):\n                    if groups[name] == group2:\n                        return {name: value2}\n        case _:\n            msg = f\"Unsupported type in infer_substitution: {subtype}\"\n            raise TypeError(msg)\n    return None\n</code></pre>"},{"location":"reference/cosy/synthesizer/","title":"synthesizer","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer","title":"<code>synthesizer</code>","text":"<p>Synthesizer implementing Finite Combinatory Logic with Predicates. It constructs a logic program via <code>constructSolutionSpace</code> from the following ingredients: - collection of component specifications - parameter space - optional specification taxonomy - target specification</p>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.C","title":"<code>C = TypeVar('C', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.ParameterSpace","title":"<code>ParameterSpace = Mapping[str, Iterable | Container]</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Specification","title":"<code>Specification = Abstraction | Implication | Type</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo","title":"<code>CombinatorInfo</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>@dataclass()\nclass CombinatorInfo:\n    # container for auxiliary information about a combinator\n    prefix: list[LiteralParameter | TermParameter | Predicate]\n    groups: dict[str, str]\n    term_predicates: tuple[Callable[[dict[str, Any]], bool], ...]\n    instantiations: deque[dict[str, Any]] | None\n    type: list[list[MultiArrow]]\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.groups","title":"<code>groups: dict[str, str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.instantiations","title":"<code>instantiations: deque[dict[str, Any]] | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.prefix","title":"<code>prefix: list[LiteralParameter | TermParameter | Predicate]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.term_predicates","title":"<code>term_predicates: tuple[Callable[[dict[str, Any]], bool], ...]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.type","title":"<code>type: list[list[MultiArrow]]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.CombinatorInfo.__init__","title":"<code>__init__(prefix: list[LiteralParameter | TermParameter | Predicate], groups: dict[str, str], term_predicates: tuple[Callable[[dict[str, Any]], bool], ...], instantiations: deque[dict[str, Any]] | None, type: list[list[MultiArrow]]) -&gt; None</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.MultiArrow","title":"<code>MultiArrow</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>@dataclass(frozen=True)\nclass MultiArrow:\n    # type of shape arg1 -&gt; arg2 -&gt; ... -&gt; argN -&gt; target\n    args: tuple[Type, ...]\n    target: Type\n\n    def __str__(self) -&gt; str:\n        if len(self.args) &gt; 0:\n            return f\"{[str(a) for a in self.args]} -&gt; {self.target!s}\"\n        return str(self.target)\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.MultiArrow.args","title":"<code>args: tuple[Type, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.MultiArrow.target","title":"<code>target: Type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.MultiArrow.__init__","title":"<code>__init__(args: tuple[Type, ...], target: Type) -&gt; None</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.MultiArrow.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def __str__(self) -&gt; str:\n    if len(self.args) &gt; 0:\n        return f\"{[str(a) for a in self.args]} -&gt; {self.target!s}\"\n    return str(self.target)\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer","title":"<code>Synthesizer</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>class Synthesizer(Generic[C]):\n    def __init__(\n        self,\n        component_specifications: Mapping[C, Specification],\n        parameter_space: ParameterSpace | None = None,\n        taxonomy: Taxonomy | None = None,\n    ):\n        self.literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())\n        self.repository: tuple[tuple[C, CombinatorInfo], ...] = tuple(\n            (c, Synthesizer._function_types(self.literals, ty)) for c, ty in component_specifications.items()\n        )\n        self.subtypes = Subtypes(taxonomy if taxonomy is not None else {})\n\n    @staticmethod\n    def _function_types(\n        literals: ParameterSpace,\n        parameterized_type: Specification,\n    ) -&gt; CombinatorInfo:\n        \"\"\"Presents a type as a list of 0-ary, 1-ary, ..., n-ary function types.\"\"\"\n\n        def unary_function_types(ty: Type) -&gt; Iterable[tuple[Type, Type]]:\n            tys: deque[Type] = deque((ty,))\n            while tys:\n                match tys.pop():\n                    case Arrow(src, tgt) if not tgt.is_omega:\n                        yield (src, tgt)\n                    case Intersection(sigma, tau):\n                        tys.extend((sigma, tau))\n\n        prefix: list[LiteralParameter | TermParameter | Predicate] = []\n        variables: set[str] = set()\n        groups: dict[str, str] = {}\n        while not isinstance(parameterized_type, Type):\n            if isinstance(parameterized_type, Abstraction):\n                param = parameterized_type.parameter\n                if param.name in variables:\n                    # check if parameter names are unique\n                    msg = f\"Duplicate name: {param.name}\"\n                    raise ValueError(msg)\n                variables.add(param.name)\n                if isinstance(param, LiteralParameter):\n                    prefix.append(param)\n                    groups[param.name] = param.group\n                    # check if group is defined in the parameter space\n                    if param.group not in literals:\n                        msg = f\"Group {param.group} is not defined in the parameter space.\"\n                        raise ValueError(msg)\n                elif isinstance(param, TermParameter):\n                    prefix.append(param)\n                    for free_var in param.group.free_vars:\n                        if free_var not in groups:\n                            # check if each parameter variable is abstracted\n                            msg = f\"Parameter {free_var} is not abstracted.\"\n                            raise ValueError(msg)\n                parameterized_type = parameterized_type.body\n            elif isinstance(parameterized_type, Implication):\n                prefix.append(parameterized_type.predicate)\n                parameterized_type = parameterized_type.body\n\n        for free_var in parameterized_type.free_vars:\n            if free_var not in groups:\n                # check if each parameter variable is abstracted\n                msg = f\"Parameter {free_var} is not abstracted.\"\n                raise ValueError(msg)\n\n        current: list[MultiArrow] = [MultiArrow((), parameterized_type)]\n\n        multiarrows = []\n        while len(current) != 0:\n            multiarrows.append(current)\n            current = [\n                MultiArrow((*c.args, new_arg), new_tgt)\n                for c in current\n                for (new_arg, new_tgt) in unary_function_types(c.target)\n            ]\n\n        term_predicates: tuple[Callable[[dict[str, Any]], bool], ...] = tuple(\n            p.constraint for p in prefix if isinstance(p, Predicate) and not p.only_literals\n        )\n        return CombinatorInfo(prefix, groups, term_predicates, None, multiarrows)\n\n    def _enumerate_substitutions(\n        self,\n        prefix: list[LiteralParameter | TermParameter | Predicate],\n        substitution: dict[str, Any],\n    ) -&gt; Iterable[dict[str, Any]]:\n        \"\"\"Enumerate all substitutions for the given parameters fairly.\n        Take initial_substitution with inferred literals into account.\"\"\"\n\n        stack: deque[tuple[dict[str, Any], int, Iterator[Any] | None]] = deque([(substitution, 0, None)])\n\n        while stack:\n            substitution, index, generator = stack.pop()\n            if index &gt;= len(prefix):\n                # no more parameters to process\n                yield substitution\n                continue\n            parameter = prefix[index]\n            if isinstance(parameter, LiteralParameter):\n                if generator is None:\n                    if parameter.name in substitution:\n                        value = substitution[parameter.name]\n                        if parameter.values is not None and value not in parameter.values(substitution):\n                            # the inferred value is not in the set of values\n                            continue\n                        if value not in self.literals[parameter.group]:\n                            # the inferred value is not in the group\n                            continue\n                        stack.appendleft((substitution, index + 1, None))\n                    elif parameter.values is not None:\n                        stack.appendleft((substitution, index, iter(parameter.values(substitution))))\n                    else:\n                        concrete_values = self.literals[parameter.group]\n                        if not isinstance(concrete_values, Iterable):\n                            msg = f\"The value of {parameter.name} could not be inferred.\"\n                            raise RuntimeError(msg)\n                        else:\n                            stack.appendleft((substitution, index, iter(concrete_values)))\n                else:\n                    try:\n                        value = next(generator)\n                    except StopIteration:\n                        continue\n                    if value in self.literals[parameter.group]:\n                        stack.appendleft(({**substitution, parameter.name: value}, index + 1, None))\n                    stack.appendleft((substitution, index, generator))\n\n            elif isinstance(parameter, Predicate) and parameter.only_literals:\n                if parameter.constraint(substitution):\n                    # the predicate is satisfied\n                    stack.appendleft((substitution, index + 1, None))\n            else:\n                stack.appendleft((substitution, index + 1, None))\n\n    def _subqueries(\n        self,\n        nary_types: list[MultiArrow],\n        paths: Iterable[Type],\n        groups: dict[str, str],\n        substitution: dict[str, Any],\n    ) -&gt; Sequence[list[Type]]:\n        # does the target of a multi-arrow contain a given type?\n        def target_contains(m: MultiArrow, t: Type) -&gt; bool:\n            return self.subtypes.check_subtype(m.target, t, groups, substitution)\n\n        # cover target using targets of multi-arrows in nary_types\n        covers = minimal_covers(nary_types, paths, target_contains)\n        if len(covers) == 0:\n            return []\n\n        # intersect corresponding arguments of multi-arrows in each cover\n        def intersect_args(args1: Iterable[Type], args2: Iterable[Type]) -&gt; tuple[Type, ...]:\n            return tuple(Intersection(a, b) for a, b in zip(args1, args2, strict=False))\n\n        intersected_args: Generator[list[Type]] = (list(reduce(intersect_args, (m.args for m in ms))) for ms in covers)\n\n        # consider only maximal argument vectors\n        def compare_args(args1, args2) -&gt; bool:\n            return all(\n                map(\n                    lambda a, b: self.subtypes.check_subtype(a, b, groups, substitution),\n                    args1,\n                    args2,\n                )\n            )\n\n        return maximal_elements(intersected_args, compare_args)\n\n    def _necessary_substitution(\n        self,\n        paths: Iterable[Type],\n        combinator_type: list[list[MultiArrow]],\n        groups: dict[str, str],\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Computes a substitution that needs to be part of every substitution S such that\n        S(combinator_type) &lt;= paths.\n\n        If no substitution can make this valid, None is returned.\n        \"\"\"\n\n        result: dict[str, Any] = {}\n\n        for path in paths:\n            unique_substitution: dict[str, Any] | None = None\n            is_unique = True\n\n            for nary_types in combinator_type:\n                for ty in nary_types:\n                    substitution = self.subtypes.infer_substitution(ty.target, path, groups)\n                    if substitution is None:\n                        continue\n                    if unique_substitution is None:\n                        unique_substitution = substitution\n                    else:\n                        is_unique = False\n                        break\n                if not is_unique:\n                    break\n\n            if unique_substitution is None:\n                return None  # no substitution for this path\n            if not is_unique:\n                continue  # substitution not unique substitution \u2014 skip\n\n            # merge consistent substitution\n            for k, v in unique_substitution.items():\n                if k in result:\n                    if result[k] != v:\n                        return None  # conflict in necessary substitution\n                else:\n                    result[k] = v\n\n        return result\n\n    def construct_solution_space_rules(self, *targets: Type) -&gt; Generator[tuple[Type, RHSRule]]:\n        \"\"\"Generate logic program rules for the given target types.\"\"\"\n\n        # current target types\n        stack: deque[tuple[Type, tuple[C, CombinatorInfo, Iterator] | None]] = deque(\n            (target, None) for target in targets\n        )\n        seen: set[Type] = set()\n\n        while stack:\n            current_target, current_target_info = stack.pop()\n            # if the target is omega, then the result is junk\n            if current_target.is_omega:\n                msg = f\"Target type {current_target} is omega.\"\n                raise ValueError(msg)\n\n            # target type was not initialized before\n            if current_target not in seen or current_target_info is not None:\n                if current_target_info is None:\n                    seen.add(current_target)\n                    # try each combinator\n                    for combinator, combinator_info in self.repository:\n                        # Compute necessary substitutions\n                        substitution = self._necessary_substitution(\n                            current_target.organized,\n                            combinator_info.type,\n                            combinator_info.groups,\n                        )\n\n                        # If there cannot be a suitable substitution, ignore this combinator\n                        if substitution is None:\n                            continue\n\n                        # Keep necessary substitutions and enumerate the rest\n                        selected_instantiations = self._enumerate_substitutions(combinator_info.prefix, substitution)\n                        stack.appendleft(\n                            (\n                                current_target,\n                                (\n                                    combinator,\n                                    combinator_info,\n                                    iter(selected_instantiations),\n                                ),\n                            )\n                        )\n                else:\n                    combinator, combinator_info, selected_instantiations = current_target_info\n                    instantiation = next(selected_instantiations, None)\n                    if instantiation is not None:\n                        stack.appendleft((current_target, current_target_info))\n                        named_arguments: tuple[Argument, ...] | None = None\n\n                        # and every arity of the combinator type\n                        for nary_types in combinator_info.type:\n                            for subquery in self._subqueries(\n                                nary_types,\n                                current_target.organized,\n                                combinator_info.groups,\n                                instantiation,\n                            ):\n                                if named_arguments is None:  # do this only once for each instantiation\n                                    named_arguments = tuple(\n                                        ConstantArgument(\n                                            param.name,\n                                            instantiation[param.name],\n                                            combinator_info.groups[param.name],\n                                        )\n                                        if isinstance(param, LiteralParameter)\n                                        else NonTerminalArgument(\n                                            param.name,\n                                            param.group.subst(\n                                                combinator_info.groups,\n                                                instantiation,\n                                            ),\n                                        )\n                                        for param in combinator_info.prefix\n                                        if isinstance(param, Parameter)\n                                    )\n                                    stack.extendleft(\n                                        (argument.origin, None)\n                                        for argument in named_arguments\n                                        if isinstance(argument, NonTerminalArgument)\n                                    )\n\n                                anonymous_arguments: tuple[Argument, ...] = tuple(\n                                    NonTerminalArgument(\n                                        None,\n                                        ty.subst(combinator_info.groups, instantiation),\n                                    )\n                                    for ty in subquery\n                                )\n                                yield (\n                                    current_target,\n                                    RHSRule[Type, Any, str](\n                                        (*named_arguments, *anonymous_arguments),\n                                        combinator_info.term_predicates,\n                                        combinator,\n                                    ),\n                                )\n                                stack.extendleft((q.origin, None) for q in anonymous_arguments)\n\n    def construct_solution_space(self, *targets: Type) -&gt; SolutionSpace[Type, C, str]:\n        \"\"\"Constructs a logic program in the current environment for the given target types.\"\"\"\n\n        solution_space: SolutionSpace[Type, C, str] = SolutionSpace()\n        for nt, rule in self.construct_solution_space_rules(*targets):\n            solution_space.add_rule(nt, rule.terminal, rule.arguments, rule.predicates)\n\n        return solution_space\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.literals","title":"<code>literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.repository","title":"<code>repository: tuple[tuple[C, CombinatorInfo], ...] = tuple((c, Synthesizer._function_types(self.literals, ty)) for (c, ty) in component_specifications.items())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.subtypes","title":"<code>subtypes = Subtypes(taxonomy if taxonomy is not None else {})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.__init__","title":"<code>__init__(component_specifications: Mapping[C, Specification], parameter_space: ParameterSpace | None = None, taxonomy: Taxonomy | None = None)</code>","text":"Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def __init__(\n    self,\n    component_specifications: Mapping[C, Specification],\n    parameter_space: ParameterSpace | None = None,\n    taxonomy: Taxonomy | None = None,\n):\n    self.literals: ParameterSpace = {} if parameter_space is None else dict(parameter_space.items())\n    self.repository: tuple[tuple[C, CombinatorInfo], ...] = tuple(\n        (c, Synthesizer._function_types(self.literals, ty)) for c, ty in component_specifications.items()\n    )\n    self.subtypes = Subtypes(taxonomy if taxonomy is not None else {})\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.construct_solution_space","title":"<code>construct_solution_space(*targets: Type) -&gt; SolutionSpace[Type, C, str]</code>","text":"<p>Constructs a logic program in the current environment for the given target types.</p> Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def construct_solution_space(self, *targets: Type) -&gt; SolutionSpace[Type, C, str]:\n    \"\"\"Constructs a logic program in the current environment for the given target types.\"\"\"\n\n    solution_space: SolutionSpace[Type, C, str] = SolutionSpace()\n    for nt, rule in self.construct_solution_space_rules(*targets):\n        solution_space.add_rule(nt, rule.terminal, rule.arguments, rule.predicates)\n\n    return solution_space\n</code></pre>"},{"location":"reference/cosy/synthesizer/#cosy.synthesizer.Synthesizer.construct_solution_space_rules","title":"<code>construct_solution_space_rules(*targets: Type) -&gt; Generator[tuple[Type, RHSRule]]</code>","text":"<p>Generate logic program rules for the given target types.</p> Source code in <code>src/cosy/synthesizer.py</code> <pre><code>def construct_solution_space_rules(self, *targets: Type) -&gt; Generator[tuple[Type, RHSRule]]:\n    \"\"\"Generate logic program rules for the given target types.\"\"\"\n\n    # current target types\n    stack: deque[tuple[Type, tuple[C, CombinatorInfo, Iterator] | None]] = deque(\n        (target, None) for target in targets\n    )\n    seen: set[Type] = set()\n\n    while stack:\n        current_target, current_target_info = stack.pop()\n        # if the target is omega, then the result is junk\n        if current_target.is_omega:\n            msg = f\"Target type {current_target} is omega.\"\n            raise ValueError(msg)\n\n        # target type was not initialized before\n        if current_target not in seen or current_target_info is not None:\n            if current_target_info is None:\n                seen.add(current_target)\n                # try each combinator\n                for combinator, combinator_info in self.repository:\n                    # Compute necessary substitutions\n                    substitution = self._necessary_substitution(\n                        current_target.organized,\n                        combinator_info.type,\n                        combinator_info.groups,\n                    )\n\n                    # If there cannot be a suitable substitution, ignore this combinator\n                    if substitution is None:\n                        continue\n\n                    # Keep necessary substitutions and enumerate the rest\n                    selected_instantiations = self._enumerate_substitutions(combinator_info.prefix, substitution)\n                    stack.appendleft(\n                        (\n                            current_target,\n                            (\n                                combinator,\n                                combinator_info,\n                                iter(selected_instantiations),\n                            ),\n                        )\n                    )\n            else:\n                combinator, combinator_info, selected_instantiations = current_target_info\n                instantiation = next(selected_instantiations, None)\n                if instantiation is not None:\n                    stack.appendleft((current_target, current_target_info))\n                    named_arguments: tuple[Argument, ...] | None = None\n\n                    # and every arity of the combinator type\n                    for nary_types in combinator_info.type:\n                        for subquery in self._subqueries(\n                            nary_types,\n                            current_target.organized,\n                            combinator_info.groups,\n                            instantiation,\n                        ):\n                            if named_arguments is None:  # do this only once for each instantiation\n                                named_arguments = tuple(\n                                    ConstantArgument(\n                                        param.name,\n                                        instantiation[param.name],\n                                        combinator_info.groups[param.name],\n                                    )\n                                    if isinstance(param, LiteralParameter)\n                                    else NonTerminalArgument(\n                                        param.name,\n                                        param.group.subst(\n                                            combinator_info.groups,\n                                            instantiation,\n                                        ),\n                                    )\n                                    for param in combinator_info.prefix\n                                    if isinstance(param, Parameter)\n                                )\n                                stack.extendleft(\n                                    (argument.origin, None)\n                                    for argument in named_arguments\n                                    if isinstance(argument, NonTerminalArgument)\n                                )\n\n                            anonymous_arguments: tuple[Argument, ...] = tuple(\n                                NonTerminalArgument(\n                                    None,\n                                    ty.subst(combinator_info.groups, instantiation),\n                                )\n                                for ty in subquery\n                            )\n                            yield (\n                                current_target,\n                                RHSRule[Type, Any, str](\n                                    (*named_arguments, *anonymous_arguments),\n                                    combinator_info.term_predicates,\n                                    combinator,\n                                ),\n                            )\n                            stack.extendleft((q.origin, None) for q in anonymous_arguments)\n</code></pre>"},{"location":"reference/cosy/tree/","title":"tree","text":""},{"location":"reference/cosy/tree/#cosy.tree","title":"<code>tree</code>","text":""},{"location":"reference/cosy/tree/#cosy.tree.T","title":"<code>T = TypeVar('T', bound=Hashable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/cosy/tree/#cosy.tree.Tree","title":"<code>Tree</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>class Tree(Generic[T]):\n    root: T\n    children: tuple[\"Tree[T]\", ...]\n    size: int\n    _hash: int\n\n    def __init__(self, root: T, children: Sequence[\"Tree[T]\"] = ()) -&gt; None:\n        self.root = root\n        self.children = tuple(children)\n        self.size = 1 + sum(child.size for child in self.children)\n        self._hash = hash((self.root, self.children))\n\n    def __hash__(self) -&gt; int:\n        return self._hash\n\n    def __lt__(self, other: \"Tree[T]\") -&gt; bool:\n        return self.size &lt; other.size\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Tree):\n            return False\n        return self.size == other.size and self.root == other.root and self.children == other.children\n\n    def __rec_to_str__(self, *, outermost: bool) -&gt; str:\n        str_root = [f\"{self.root!s}\"]\n        str_args = [f\"{subtree.__rec_to_str__(outermost=False)}\" for subtree in self.children]\n\n        strings = str_root + str_args\n        if not outermost and len(strings) &gt; 1:\n            return f\"({' '.join(strings)})\"\n        return \" \".join(strings)\n\n    def __str__(self) -&gt; str:\n        return self.__rec_to_str__(outermost=True)\n\n    def interpret(self, interpretation: dict[T, Any] | None = None) -&gt; Any:\n        \"\"\"Recursively evaluate given term.\"\"\"\n\n        terms: deque[Tree[T]] = deque((self,))\n        combinators: deque[tuple[T, int]] = deque()\n        # decompose terms\n        while terms:\n            t = terms.pop()\n            combinators.append((t.root, len(t.children)))\n            terms.extend(reversed(t.children))\n        results: deque[Any] = deque()\n\n        # apply/call decomposed terms\n        while combinators:\n            (c, n) = combinators.pop()\n            parameters_of_c: Sequence[Parameter] = []\n            current_combinator: partial[Any] | T | Callable[..., Any] = (\n                c if interpretation is None or c not in interpretation else interpretation[c]\n            )\n\n            if callable(current_combinator):\n                try:\n                    parameters_of_c = list(signature(current_combinator).parameters.values())\n                except ValueError as exc:\n                    msg = (\n                        f\"Interpretation of combinator {c} does not expose a signature. \"\n                        \"If it's a built-in, you can simply wrap it in another function.\"\n                    )\n                    raise TypeError(msg) from exc\n\n                if n == 0 and len(parameters_of_c) == 0:\n                    current_combinator = current_combinator()\n\n            arguments = deque(results.pop() for _ in range(n))\n\n            while arguments:\n                if not callable(current_combinator):\n                    msg = (\n                        f\"Interpretation of combinator {c} is applied to {n} argument(s), \"\n                        f\"but can only be applied to {n - len(arguments)}\"\n                    )\n                    raise TypeError(msg)\n\n                use_partial = False\n\n                simple_arity = len(list(filter(lambda x: x.default == _empty, parameters_of_c)))\n                default_arity = len(list(filter(lambda x: x.default != _empty, parameters_of_c)))\n\n                # if any parameter is marked as var_args, we need to use all available arguments\n                pop_all = any(x.kind == _ParameterKind.VAR_POSITIONAL for x in parameters_of_c)\n\n                # If a var_args parameter is found, we need to subtract it from the normal parameters.\n                # Note: python does only allow one parameter in the form of *arg\n                if pop_all:\n                    simple_arity -= 1\n\n                # If a combinator needs more arguments than available, we need to use partial\n                # application\n                if simple_arity &gt; len(arguments):\n                    use_partial = True\n\n                fixed_parameters: deque[Any] = deque(\n                    arguments.popleft() for _ in range(min(simple_arity, len(arguments)))\n                )\n\n                var_parameters: deque[Any] = deque()\n                if pop_all:\n                    var_parameters.extend(arguments)\n                    arguments = deque()\n\n                default_parameters: deque[Any] = deque()\n                for _ in range(default_arity):\n                    with contextlib.suppress(IndexError):\n                        default_parameters.append(arguments.popleft())\n\n                if use_partial:\n                    current_combinator = partial(\n                        current_combinator,\n                        *fixed_parameters,\n                        *var_parameters,\n                        *default_parameters,\n                    )\n                else:\n                    current_combinator = current_combinator(*fixed_parameters, *var_parameters, *default_parameters)\n\n            results.append(current_combinator)\n        return results.pop()\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.children","title":"<code>children: tuple[Tree[T], ...] = tuple(children)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/tree/#cosy.tree.Tree.root","title":"<code>root: T = root</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/tree/#cosy.tree.Tree.size","title":"<code>size: int = 1 + sum(child.size for child in self.children)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/tree/#cosy.tree.Tree.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    if not isinstance(other, Tree):\n        return False\n    return self.size == other.size and self.root == other.root and self.children == other.children\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return self._hash\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.__init__","title":"<code>__init__(root: T, children: Sequence[Tree[T]] = ()) -&gt; None</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __init__(self, root: T, children: Sequence[\"Tree[T]\"] = ()) -&gt; None:\n    self.root = root\n    self.children = tuple(children)\n    self.size = 1 + sum(child.size for child in self.children)\n    self._hash = hash((self.root, self.children))\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.__lt__","title":"<code>__lt__(other: Tree[T]) -&gt; bool</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __lt__(self, other: \"Tree[T]\") -&gt; bool:\n    return self.size &lt; other.size\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.__rec_to_str__","title":"<code>__rec_to_str__(*, outermost: bool) -&gt; str</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __rec_to_str__(self, *, outermost: bool) -&gt; str:\n    str_root = [f\"{self.root!s}\"]\n    str_args = [f\"{subtree.__rec_to_str__(outermost=False)}\" for subtree in self.children]\n\n    strings = str_root + str_args\n    if not outermost and len(strings) &gt; 1:\n        return f\"({' '.join(strings)})\"\n    return \" \".join(strings)\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/tree.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__rec_to_str__(outermost=True)\n</code></pre>"},{"location":"reference/cosy/tree/#cosy.tree.Tree.interpret","title":"<code>interpret(interpretation: dict[T, Any] | None = None) -&gt; Any</code>","text":"<p>Recursively evaluate given term.</p> Source code in <code>src/cosy/tree.py</code> <pre><code>def interpret(self, interpretation: dict[T, Any] | None = None) -&gt; Any:\n    \"\"\"Recursively evaluate given term.\"\"\"\n\n    terms: deque[Tree[T]] = deque((self,))\n    combinators: deque[tuple[T, int]] = deque()\n    # decompose terms\n    while terms:\n        t = terms.pop()\n        combinators.append((t.root, len(t.children)))\n        terms.extend(reversed(t.children))\n    results: deque[Any] = deque()\n\n    # apply/call decomposed terms\n    while combinators:\n        (c, n) = combinators.pop()\n        parameters_of_c: Sequence[Parameter] = []\n        current_combinator: partial[Any] | T | Callable[..., Any] = (\n            c if interpretation is None or c not in interpretation else interpretation[c]\n        )\n\n        if callable(current_combinator):\n            try:\n                parameters_of_c = list(signature(current_combinator).parameters.values())\n            except ValueError as exc:\n                msg = (\n                    f\"Interpretation of combinator {c} does not expose a signature. \"\n                    \"If it's a built-in, you can simply wrap it in another function.\"\n                )\n                raise TypeError(msg) from exc\n\n            if n == 0 and len(parameters_of_c) == 0:\n                current_combinator = current_combinator()\n\n        arguments = deque(results.pop() for _ in range(n))\n\n        while arguments:\n            if not callable(current_combinator):\n                msg = (\n                    f\"Interpretation of combinator {c} is applied to {n} argument(s), \"\n                    f\"but can only be applied to {n - len(arguments)}\"\n                )\n                raise TypeError(msg)\n\n            use_partial = False\n\n            simple_arity = len(list(filter(lambda x: x.default == _empty, parameters_of_c)))\n            default_arity = len(list(filter(lambda x: x.default != _empty, parameters_of_c)))\n\n            # if any parameter is marked as var_args, we need to use all available arguments\n            pop_all = any(x.kind == _ParameterKind.VAR_POSITIONAL for x in parameters_of_c)\n\n            # If a var_args parameter is found, we need to subtract it from the normal parameters.\n            # Note: python does only allow one parameter in the form of *arg\n            if pop_all:\n                simple_arity -= 1\n\n            # If a combinator needs more arguments than available, we need to use partial\n            # application\n            if simple_arity &gt; len(arguments):\n                use_partial = True\n\n            fixed_parameters: deque[Any] = deque(\n                arguments.popleft() for _ in range(min(simple_arity, len(arguments)))\n            )\n\n            var_parameters: deque[Any] = deque()\n            if pop_all:\n                var_parameters.extend(arguments)\n                arguments = deque()\n\n            default_parameters: deque[Any] = deque()\n            for _ in range(default_arity):\n                with contextlib.suppress(IndexError):\n                    default_parameters.append(arguments.popleft())\n\n            if use_partial:\n                current_combinator = partial(\n                    current_combinator,\n                    *fixed_parameters,\n                    *var_parameters,\n                    *default_parameters,\n                )\n            else:\n                current_combinator = current_combinator(*fixed_parameters, *var_parameters, *default_parameters)\n\n        results.append(current_combinator)\n    return results.pop()\n</code></pre>"},{"location":"reference/cosy/types/","title":"types","text":""},{"location":"reference/cosy/types/#cosy.types","title":"<code>types</code>","text":"<p>Definition of intersection types <code>Type</code> and parameterized abstractions <code>Abstraction</code>.</p>"},{"location":"reference/cosy/types/#cosy.types.Abstraction","title":"<code>Abstraction</code>  <code>dataclass</code>","text":"<p>Abstraction of a term parameter or a literal parameter.</p> Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Abstraction:\n    \"\"\"Abstraction of a term parameter or a literal parameter.\"\"\"\n\n    parameter: Parameter\n    body: Abstraction | Implication | Type\n\n    def __str__(self) -&gt; str:\n        return f\"{self.parameter}.{self.body}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Abstraction.body","title":"<code>body: Abstraction | Implication | Type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Abstraction.parameter","title":"<code>parameter: Parameter</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Abstraction.__init__","title":"<code>__init__(parameter: Parameter, body: Abstraction | Implication | Type) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Abstraction.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.parameter}.{self.body}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Arrow","title":"<code>Arrow</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Arrow(Type):\n    source: Type = field(init=True)\n    target: Type = field(init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return self.target.is_omega\n\n    def _size(self) -&gt; int:\n        return 1 + self.source.size + self.target.size\n\n    def _organized(self) -&gt; set[Type]:\n        if len(self.target.organized) == 0:\n            return set()\n        if len(self.target.organized) == 1:\n            return {self}\n        return {Arrow(self.source, tp) for tp in self.target.organized}\n\n    def _free_vars(self) -&gt; set[str]:\n        return set.union(self.source.free_vars, self.target.free_vars)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.source} -&gt; {self.target}\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Arrow(\n            self.source.subst(groups, substitution),\n            self.target.subst(groups, substitution),\n        )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Arrow.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.source","title":"<code>source: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.target","title":"<code>target: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.__init__","title":"<code>__init__(source: Type, target: Type, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Arrow.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Arrow.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.source} -&gt; {self.target}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Arrow.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Arrow(\n        self.source.subst(groups, substitution),\n        self.target.subst(groups, substitution),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Constructor","title":"<code>Constructor</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Constructor(Type):\n    name: str = field(init=True)\n    arg: Type = field(default=Omega(), init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1 + self.arg.size\n\n    def _organized(self) -&gt; set[Type]:\n        if len(self.arg.organized) &lt;= 1:\n            return {self}\n        return {Constructor(self.name, ap) for ap in self.arg.organized}\n\n    def _free_vars(self) -&gt; set[str]:\n        return self.arg.free_vars\n\n    def __str__(self) -&gt; str:\n        if self.arg == Omega():\n            return str(self.name)\n        return f\"{self.name!s}({self.arg!s})\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Constructor(self.name, self.arg.subst(groups, substitution))\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Constructor.arg","title":"<code>arg: Type = field(default=Omega(), init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.name","title":"<code>name: str = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.__init__","title":"<code>__init__(name: str, arg: Type = Omega(), *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Constructor.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Constructor.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.arg == Omega():\n        return str(self.name)\n    return f\"{self.name!s}({self.arg!s})\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Constructor.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Constructor(self.name, self.arg.subst(groups, substitution))\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Implication","title":"<code>Implication</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Implication:\n    predicate: Predicate\n    body: Abstraction | Implication | Type\n\n    def __str__(self) -&gt; str:\n        return f\"{self.predicate} =&gt; {self.body}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Implication.body","title":"<code>body: Abstraction | Implication | Type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Implication.predicate","title":"<code>predicate: Predicate</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Implication.__init__","title":"<code>__init__(predicate: Predicate, body: Abstraction | Implication | Type) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Implication.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.predicate} =&gt; {self.body}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Intersection","title":"<code>Intersection</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Intersection(Type):\n    left: Type = field(init=True)\n    right: Type = field(init=True)\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return self.left.is_omega and self.right.is_omega\n\n    def _size(self) -&gt; int:\n        return 1 + self.left.size + self.right.size\n\n    def _organized(self) -&gt; set[Type]:\n        return set.union(self.left.organized, self.right.organized)\n\n    def _free_vars(self) -&gt; set[str]:\n        return set.union(self.left.free_vars, self.right.free_vars)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.left} &amp; {self.right}\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if not any(var in substitution for var in self.free_vars):\n            return self\n        return Intersection(\n            self.left.subst(groups, substitution),\n            self.right.subst(groups, substitution),\n        )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Intersection.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.left","title":"<code>left: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.right","title":"<code>right: Type = field(init=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.__init__","title":"<code>__init__(left: Type, right: Type, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Intersection.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Intersection.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.left} &amp; {self.right}\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Intersection.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if not any(var in substitution for var in self.free_vars):\n        return self\n    return Intersection(\n        self.left.subst(groups, substitution),\n        self.right.subst(groups, substitution),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Literal","title":"<code>Literal</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Literal(Type):\n    value: Any  # has to be Hashable\n    group: str\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return {self}\n\n    def _free_vars(self) -&gt; set[str]:\n        return set()\n\n    def __str__(self) -&gt; str:\n        return f\"[{self.value!s}, {self.group}]\"\n\n    def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n        return self\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Literal.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.group","title":"<code>group: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.value","title":"<code>value: Any</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.__init__","title":"<code>__init__(value: Any, group: str, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Literal.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Literal.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"[{self.value!s}, {self.group}]\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Literal.subst","title":"<code>subst(_groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n    return self\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.LiteralParameter","title":"<code>LiteralParameter</code>  <code>dataclass</code>","text":"<p>Specification of a literal parameter.</p> Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass LiteralParameter(Parameter):\n    \"\"\"Specification of a literal parameter.\"\"\"\n\n    group: str\n    #  Specification of literal assignment from a collection\n    values: Callable[[dict[str, Any]], Sequence[Any]] | None = field(default=None)\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.LiteralParameter.group","title":"<code>group: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.LiteralParameter.values","title":"<code>values: Callable[[dict[str, Any]], Sequence[Any]] | None = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.LiteralParameter.__init__","title":"<code>__init__(name: str, group: str, values: Callable[[dict[str, Any]], Sequence[Any]] | None = None) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega","title":"<code>Omega</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Omega(Type):\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return True\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return set()\n\n    def __str__(self) -&gt; str:\n        return \"omega\"\n\n    def _free_vars(self) -&gt; set[str]:\n        return set()\n\n    def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n        return self\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Omega.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega.__init__","title":"<code>__init__(*, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Omega.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Omega.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return \"omega\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Omega.subst","title":"<code>subst(_groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, _groups: Mapping[str, str], _substitution: dict[str, Any]) -&gt; Type:\n    return self\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Abstract base class for parameter specification.</p> Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Parameter(ABC):\n    \"\"\"Abstract base class for parameter specification.\"\"\"\n\n    name: str\n    group: str | Type\n\n    def __str__(self) -&gt; str:\n        return f\"&lt;{self.name}, {self.group}&gt;\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Parameter.group","title":"<code>group: str | Type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Parameter.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Parameter.__init__","title":"<code>__init__(name: str, group: str | Type) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Parameter.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"&lt;{self.name}, {self.group}&gt;\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Predicate","title":"<code>Predicate</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Predicate:\n    constraint: Callable[[dict[str, Any]], bool]\n    only_literals: bool\n\n    def __str__(self) -&gt; str:\n        return f\"[{self.constraint.__name__}, only literals]\" if self.only_literals else f\"[{self.constraint.__name__}]\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Predicate.constraint","title":"<code>constraint: Callable[[dict[str, Any]], bool]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Predicate.only_literals","title":"<code>only_literals: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Predicate.__init__","title":"<code>__init__(constraint: Callable[[dict[str, Any]], bool], only_literals: bool) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Predicate.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"[{self.constraint.__name__}, only literals]\" if self.only_literals else f\"[{self.constraint.__name__}]\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.TermParameter","title":"<code>TermParameter</code>  <code>dataclass</code>","text":"<p>Specification of a term parameter.</p> Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass TermParameter(Parameter):\n    \"\"\"Specification of a term parameter.\"\"\"\n\n    group: Type\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.TermParameter.group","title":"<code>group: Type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.TermParameter.__init__","title":"<code>__init__(name: str, group: Type) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type","title":"<code>Type</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Type(ABC):\n    is_omega: bool = field(init=True, kw_only=True, compare=False)\n    size: int = field(init=True, kw_only=True, compare=False)\n    organized: set[Type] = field(init=True, kw_only=True, compare=False)\n    free_vars: set[str] = field(init=True, kw_only=True, compare=False)\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def _organized(self) -&gt; set[Type]:\n        pass\n\n    @abstractmethod\n    def _size(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def _is_omega(self) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def _free_vars(self) -&gt; set[str]:\n        pass\n\n    @abstractmethod\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        pass\n\n    @staticmethod\n    def intersect(types: Sequence[Type]) -&gt; Type:\n        if len(types) &gt; 0:\n            rtypes = reversed(types)\n            result: Type = next(rtypes)\n            for ty in rtypes:\n                result = Intersection(ty, result)\n            return result\n        return Omega()\n\n    def __getstate__(self) -&gt; dict[str, Any]:\n        state = self.__dict__.copy()\n        del state[\"is_omega\"]\n        del state[\"size\"]\n        del state[\"organized\"]\n        return state\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        self.__dict__.update(state)\n        self.__dict__[\"is_omega\"] = self._is_omega()\n        self.__dict__[\"size\"] = self._size()\n        self.__dict__[\"organized\"] = self._organized()\n\n    def __pow__(self, other: Type) -&gt; Type:\n        return Arrow(self, other)\n\n    def __and__(self, other: Type) -&gt; Type:\n        return Intersection(self, other)\n\n    def __rmatmul__(self, name: str) -&gt; Type:\n        return Constructor(name, self)\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.free_vars","title":"<code>free_vars: set[str] = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type.is_omega","title":"<code>is_omega: bool = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type.organized","title":"<code>organized: set[Type] = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type.size","title":"<code>size: int = field(init=True, kw_only=True, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type.__and__","title":"<code>__and__(other: Type) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __and__(self, other: Type) -&gt; Type:\n    return Intersection(self, other)\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.__getstate__","title":"<code>__getstate__() -&gt; dict[str, Any]</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __getstate__(self) -&gt; dict[str, Any]:\n    state = self.__dict__.copy()\n    del state[\"is_omega\"]\n    del state[\"size\"]\n    del state[\"organized\"]\n    return state\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.__init__","title":"<code>__init__(*, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Type.__pow__","title":"<code>__pow__(other: Type) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __pow__(self, other: Type) -&gt; Type:\n    return Arrow(self, other)\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.__rmatmul__","title":"<code>__rmatmul__(name: str) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __rmatmul__(self, name: str) -&gt; Type:\n    return Constructor(name, self)\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.__setstate__","title":"<code>__setstate__(state: dict[str, Any]) -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __setstate__(self, state: dict[str, Any]) -&gt; None:\n    self.__dict__.update(state)\n    self.__dict__[\"is_omega\"] = self._is_omega()\n    self.__dict__[\"size\"] = self._size()\n    self.__dict__[\"organized\"] = self._organized()\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.__str__","title":"<code>__str__() -&gt; str</code>  <code>abstractmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@abstractmethod\ndef __str__(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.intersect","title":"<code>intersect(types: Sequence[Type]) -&gt; Type</code>  <code>staticmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@staticmethod\ndef intersect(types: Sequence[Type]) -&gt; Type:\n    if len(types) &gt; 0:\n        rtypes = reversed(types)\n        result: Type = next(rtypes)\n        for ty in rtypes:\n            result = Intersection(ty, result)\n        return result\n    return Omega()\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Type.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>  <code>abstractmethod</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@abstractmethod\ndef subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    pass\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Var","title":"<code>Var</code>  <code>dataclass</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Var(Type):\n    name: str\n    is_omega: bool = field(init=False, compare=False)\n    size: int = field(init=False, compare=False)\n    organized: set[Type] = field(init=False, compare=False)\n    free_vars: set[str] = field(init=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__init__(\n            is_omega=self._is_omega(),\n            size=self._size(),\n            organized=self._organized(),\n            free_vars=self._free_vars(),\n        )\n\n    def _is_omega(self) -&gt; bool:\n        return False\n\n    def _size(self) -&gt; int:\n        return 1\n\n    def _organized(self) -&gt; set[Type]:\n        return {self}\n\n    def _free_vars(self) -&gt; set[str]:\n        return {self.name}\n\n    def __str__(self) -&gt; str:\n        return f\"&lt;{self.name!s}&gt;\"\n\n    def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n        if self.name in substitution:\n            return Literal(substitution[self.name], groups[self.name])\n        return self\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Var.free_vars","title":"<code>free_vars: set[str] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.is_omega","title":"<code>is_omega: bool = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.organized","title":"<code>organized: set[Type] = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.size","title":"<code>size: int = field(init=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.__init__","title":"<code>__init__(name: str, *, is_omega: bool, size: int, organized: set[Type], free_vars: set[str]) -&gt; None</code>","text":""},{"location":"reference/cosy/types/#cosy.types.Var.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__init__(\n        is_omega=self._is_omega(),\n        size=self._size(),\n        organized=self._organized(),\n        free_vars=self._free_vars(),\n    )\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Var.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"&lt;{self.name!s}&gt;\"\n</code></pre>"},{"location":"reference/cosy/types/#cosy.types.Var.subst","title":"<code>subst(groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type</code>","text":"Source code in <code>src/cosy/types.py</code> <pre><code>def subst(self, groups: Mapping[str, str], substitution: dict[str, Any]) -&gt; Type:\n    if self.name in substitution:\n        return Literal(substitution[self.name], groups[self.name])\n    return self\n</code></pre>"}]}